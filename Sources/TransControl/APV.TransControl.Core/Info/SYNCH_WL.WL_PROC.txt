
  CREATE OR REPLACE PACKAGE "SYNCH_WL"."WL_PROC" IS

-- Define Types

  TYPE TDBLinkNameArray IS TABLE OF NVARCHAR2(50) INDEX BY BINARY_INTEGER;
  TYPE TPointArray IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
  TYPE TNumberArray IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
  TYPE TDateArray IS TABLE OF DATE INDEX BY BINARY_INTEGER;
  TYPE TStringArray IS TABLE OF NVARCHAR2(300) INDEX BY BINARY_INTEGER;

  TYPE TAddEquipmentTable IS TABLE OF SYNCH_WL.ADD_EQUIPMENT%ROWTYPE INDEX BY BINARY_INTEGER;

  TYPE TCursor IS REF CURSOR;

  TYPE TMonPosCursor IS REF CURSOR RETURN MONUSER.MONPOS%ROWTYPE;

-- Define consts

  CFORMAT_TIME_AND_PATH CONSTANT RAW(4) := HEXTORAW('22000000'); --  FORMAT.TIME | FORMAT.PATH
  CFORMAT_VELOCITY CONSTANT RAW(4)      := HEXTORAW('10000000'); --  FORMAT.VELOCITY
  CFORMAT_LAT_LON CONSTANT RAW(4)       := HEXTORAW('04000000'); --  FORMAT.LATITUDE_LONGITUDE
  CFORMAT_PORT_S CONSTANT VARCHAR2(8)   := '40000000';           --  FORMAT.PORT_S

  CRESULT_SUCCESS CONSTANT NUMBER   := 0;
  CRESULT_NOTFOUND CONSTANT NUMBER  := -1;
  CRESULT_EXCEPTION CONSTANT NUMBER := -2;

  CFLAG_GT CONSTANT CHAR(2) := '>'; -- '>'
  CFLAG_GE CONSTANT CHAR(2) := '>='; -- '>='
  CFLAG_LT CONSTANT CHAR(2) := '<'; -- '<'
  CFLAG_LE CONSTANT CHAR(2) := '<='; -- '<='
  CFLAG_NE CONSTANT CHAR(2) := '<>'; -- '<>'

  WORKING_RADIUS CONSTANT NUMBER := 100.0; -- 100 meters
  MAX_FUEL_FREQ CONSTANT NUMBER := 99999.0; -- 99999 Hz

  FUEL_LOAD_FUEL_LIMIT CONSTANT NUMBER := 10; -- 10 l
  FUEL_LOAD_TIME_LIMIT CONSTANT NUMBER := 25; -- 25 min
  FUEL_DRAIN_FUEL_LIMIT CONSTANT NUMBER := 5; -- 5 l
  FUEL_DRAIN_TIME_LIMIT CONSTANT NUMBER := 25; -- 25 min
  FUEL_DRAIN_ENGINE_CONTROL CONSTANT BOOLEAN := TRUE;

-- Common functions

FUNCTION TotalHours
  (BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER;

FUNCTION ConvertAvtoNo
  (AVTO_NO IN NVARCHAR2)
  RETURN NVARCHAR2;

FUNCTION GetObjIdByAvtoNo
  (AVTONO IN NVARCHAR2)
  RETURN NUMBER;

FUNCTION GetAvtoNoByObjId
  (OBJ_ID IN NUMBER)
  RETURN NVARCHAR2;

FUNCTION IsDSTAvtoByAvtoNo
  (AVTO_NO IN NVARCHAR2)
  RETURN NUMBER;

FUNCTION GetAddress
  (LAT IN NUMBER,
   LON IN NUMBER)
  RETURN NVARCHAR2;

FUNCTION NumberArrayToString
  (NumberArray IN TNumberArray,
   Separator IN NVARCHAR2 := ';')
  RETURN NVARCHAR2;

FUNCTION IntArrayToString
  (IntArray IN TNumberArray,
   Separator IN NVARCHAR2 := ';')
  RETURN NVARCHAR2;

FUNCTION StringArrayToString
  (StringArray IN TStringArray,
   Separator IN NVARCHAR2 := ';')
  RETURN NVARCHAR2;

FUNCTION DetailDataArrayToString
  (NAME_ARRAY IN TStringArray,
   MOTO_TYPE_ARRAY IN TNumberArray,
   MOTO_ARRAY IN TNumberArray,
   MOTO_COUNT_ARRAY IN TNumberArray,
   FUEL_ARRAY IN TNumberArray,
   ADDRESS_ARRAY IN TStringArray)
  RETURN NVARCHAR2;

FUNCTION GetMonPosTable
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN SYNCH_WL."TMonPosTable";

FUNCTION GetMonPosTableC
  (MonPosCursor TMonPosCursor)
  RETURN SYNCH_WL."TMonPosTable";

FUNCTION GetParamsFromMonPosTable
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   ObjIdArray OUT TNumberArray,
   BEGINDATE OUT DATE,
   ENDDATE OUT DATE)
  RETURN NUMBER;

PROCEDURE LOG_STK
  (DB_BEGIN IN DATE,
   DT_END IN DATE,
   AVTO_NO IN NVARCHAR2,
   OBJ_ID IN NUMBER,
   R_MOTO IN NUMBER,
   R_DIST IN NUMBER,
   S_DETAIL IN NVARCHAR2);

FUNCTION TO_GMT
  (EVGMT IN DATE)
  RETURN DATE;

FUNCTION TO_EVGMT
  (GMT IN DATE)
  RETURN DATE;

FUNCTION IS_GMT_WINTER_TIME
  (GMT IN DATE)
  RETURN NUMBER;

FUNCTION IS_EVGMT_WINTER_TIME
  (EVGMT IN DATE)
  RETURN NUMBER;

FUNCTION IS_CORRECT_DATETIME
    RETURN NUMBER;

-- DIST

FUNCTION CalcDistByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER;

FUNCTION CalcDistByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER;

FUNCTION CalcDistByObjIdC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER;

FUNCTION CalcDistByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER;

FUNCTION GR_DIST_GEO
  (X_LAT NUMBER,
   X_LON NUMBER,
   Y_LAT NUMBER,
   Y_LON NUMBER)
  RETURN NUMBER;

FUNCTION GR_DITS_DURSHIN
  (X_LAT NUMBER,
   X_LON NUMBER,
   Y_LAT NUMBER,
   Y_LON NUMBER)
  RETURN NUMBER;

FUNCTION CalcGEODistByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER;

FUNCTION CalcDurshinDistByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER;

-- MOTO

FUNCTION InsertUpdateDSTMask
  (MASK_NAME IN NVARCHAR2,
   FUEL_CONSUMPTION IN NUMBER,
   MASK IN RAW,
   MASK_DESCRIPTION IN NVARCHAR2 := '',
   SPEED_CONDITION_FLAG IN CHAR := NULL,
   SPEED_CONDITION IN NUMBER := 0.0,
   STATE_MASK IN RAW := HEXTORAW('00000000'),
   ADDRESS_ENABLED IN NUMBER := 1,
   COUNT_MODE IN NUMBER := 0,
   ALGORITHM_MASK IN RAW := HEXTORAW('00000000000000000000000000000000'))
  RETURN NUMBER;

FUNCTION DeleteDSTMask
  (MASK_NAME IN NVARCHAR2)
  RETURN NUMBER;

FUNCTION AddMaskToTemplate
  (TEMPLATE_NAME IN NVARCHAR2,
   MASK_NAME IN NVARCHAR2)
   RETURN NUMBER;

FUNCTION DelMaskFromTemplate
  (TEMPLATE_NAME IN NVARCHAR2,
   MASK_NAME IN NVARCHAR2)
   RETURN NUMBER;

FUNCTION AddDSTMaskToObjByObjId
  (MASK_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER;

FUNCTION DelDSTMaskFromObjByObjId
  (MASK_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER;

FUNCTION AddTemplateToObjByObjId
  (TEMPLATE_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER;

FUNCTION ReplaceTemplateToObjByObjId
  (TEMPLATE_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER;

FUNCTION AddTemplateToObjByAvtoNo
  (TEMPLATE_NAME IN NVARCHAR2,
   AVTO_NO IN NVARCHAR2)
  RETURN NUMBER;

FUNCTION DeleteTemplate
  (TEMPLATE_NAME IN NVARCHAR2)
  RETURN NUMBER;

FUNCTION DelAllMasksFromObjByObjId
  (OBJ_ID IN NUMBER)
  RETURN NUMBER;

FUNCTION GetDSTMaskByObjId
  (OBJ_ID IN NUMBER,
   AddEquipmentTable OUT TAddEquipmentTable)
  RETURN NUMBER;

FUNCTION CalcDistByAcceleration
  (BEGIN_SPEED IN NUMBER,
   END_SPEED IN NUMBER,
   DT IN NUMBER)
  RETURN NUMBER;

FUNCTION CalcTimeInMovingByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   DIST OUT NUMBER)
  RETURN NUMBER;

FUNCTION AlgMaskToSQLCondition
  (PINPUT IN RAW,
   INPUT IN RAW,
   ALGORITHM_MASK IN RAW)
  RETURN RAW;

FUNCTION MaskToSQLCondition
  (AddEquipmentItem IN SYNCH_WL.ADD_EQUIPMENT%ROWTYPE,
   IsAddressMode IN NUMBER := 0,
   CountModeControl IN NUMBER := 0)
   RETURN NVARCHAR2;

FUNCTION MaskArrayToSQLCondition
  (MaskArray IN TAddEquipmentTable,
   IsAddressMode IN NUMBER := 0,
   CountModeControl IN NUMBER := 0)
  RETURN NVARCHAR2;

FUNCTION MaskArrayToFuelSQLCondition
  (MaskArray IN TAddEquipmentTable,
   CountModeControl IN NUMBER := 0)
  RETURN NVARCHAR2;

FUNCTION CalcDSTMotoByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0,
   MotoCountMode IN NUMBER := 1)
  RETURN NUMBER;

FUNCTION CalcDSTMotoByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0,
   MotoCountMode IN NUMBER := 1)
  RETURN NUMBER;

FUNCTION CalcFullDSTMotoByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0)
  RETURN NUMBER;

FUNCTION CalcFullDSTMotoByObjIdC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0)
  RETURN NUMBER;

FUNCTION CalcFullDSTMotoByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0)
  RETURN NUMBER;

FUNCTION CalcDetailDSTMotoByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   AddEquipmentNames OUT VARCHAR2,
   MotoDetails OUT VARCHAR2,
   FuelConsumptionDetails OUT VARCHAR2)
  RETURN NUMBER;

FUNCTION CalcDetailDSTMotoByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   AddEquipmentNames OUT VARCHAR2,
   MotoDetails OUT VARCHAR2,
   FuelConsumptionDetails OUT VARCHAR2)
  RETURN NUMBER;

FUNCTION CalcDetailDSTMotoByObjIdCT
  (MonPosCursor IN TMonPosCursor)
  RETURN SYNCH_WL."TWorkingPointTable";

FUNCTION CalcDetailDSTMotoByObjIdTT
  (MonPosTable IN SYNCH_WL."TMonPosTable")
  RETURN SYNCH_WL."TWorkingPointTable";

-- Working X, Y Pos

FUNCTION FastBall
  (p_x IN TPointArray,
   p_y IN TPointArray,
   c_x OUT NUMBER,
   c_y OUT NUMBER)
  RETURN NUMBER;

FUNCTION IsInCircle
  (X IN NUMBER,
   Y IN NUMBER,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER)
  RETURN NUMBER;

FUNCTION GetFirstWorkingPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER;

FUNCTION GetFirstWorkingPointC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER;

FUNCTION GetFirstWorkingPointT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER;

FUNCTION GetNextWorkingPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER;

FUNCTION GetNextWorkingPointT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER;

FUNCTION GetWorkingPointDate
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   BeginAt OUT DATE,
   EndAt OUT DATE)
  RETURN NUMBER;

FUNCTION GetWorkingPointDateT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   BeginAt OUT DATE,
   EndAt OUT DATE)
  RETURN NUMBER;

FUNCTION GetWorkingPointCoordT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   p_x OUT TPointArray,
   p_y OUT TPointArray)
  RETURN NUMBER;

FUNCTION GetFirstFullDSTPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER;

FUNCTION GetFirstFullDSTPointC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER;

FUNCTION GetFirstFullDSTPointT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER;

FUNCTION GetWorkingPointMoto
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   AddEquipmentNameArray OUT TStringArray,
   MotoTypeArray OUT TNumberArray,
   MotoArray OUT TNumberArray,
   MotoCountArray OUT TNumberArray,
   FuelArray OUT TNumberArray,
   AddressArray OUT TStringArray,
   TotalMoto OUT NUMBER,
   TotalFuel OUT NUMBER)
  RETURN NUMBER;

FUNCTION GetWorkingPointMotoT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   AddEquipmentNameArray OUT TStringArray,
   MotoTypeArray OUT TNumberArray,
   MotoArray OUT TNumberArray,
   MotoCountArray OUT TNumberArray,
   FuelArray OUT TNumberArray,
   AddressArray OUT TStringArray,
   TotalMoto OUT NUMBER,
   TotalFuel OUT NUMBER)
  RETURN NUMBER;

FUNCTION GetAllWorkingPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   BeginAt OUT TDateArray,
   EndAt OUT TDateArray,
   X OUT TPointArray,
   Y OUT TPointArray,
   FullMoto OUT TNumberArray,
   FullFuel OUT TNumberArray,
   AddEquipmentNames OUT TStringArray,
   MotoDetails OUT TStringArray,
   FuelDetails OUT TStringArray)
  RETURN NUMBER;

FUNCTION GetAllWorkingPointC
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN TCursor;

FUNCTION GetAllAddressesT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X_ARRAY OUT TNumberArray,
   Y_ARRAY OUT TNumberArray,
   ADDRESS_ARRAY OUT TStringArray)
  RETURN NUMBER;

FUNCTION TestFastBall
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER;

-- Connections with DB LInk

FUNCTION EverestDBLinks
  RETURN TDBLinkNameArray;

FUNCTION GetDBLinkNameToEverest
  (AVTO_NO IN NVARCHAR2,
   OBJ_ID IN NUMBER)
  RETURN NVARCHAR2;

FUNCTION GetMainDataFromEverestByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   MODEL OUT VARCHAR,
   VEHICLETYPE OUT CHAR,
   ADMINNAME OUT VARCHAR2,
   FUELCONSUMPTION OUT NUMBER,
   WORKGRAPHTYPENAME OUT VARCHAR2,
   DINNERTIME OUT CHAR)
   RETURN NUMBER;

FUNCTION GetFuelConsFromEverestByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   p_RegDate IN DATE)
  RETURN NUMBER;

FUNCTION GetWayListIdByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
   RETURN TCursor;

-- FUEL CONFIG PARSING

FUNCTION ReadFuelTransformFromConfig
  (CONFIG VARCHAR2, TransformationList OUT VARCHAR2)
   RETURN NUMBER;

FUNCTION ParseFuelTransform
  (OBJID NUMBER, TransformationList VARCHAR2)
   RETURN SYNCH_WL."TFuelTransformationTable";

FUNCTION CalcFuelTransform
  (FREQ NUMBER, Transform SYNCH_WL."TFuelTransformationTable")
   RETURN NUMBER;

FUNCTION CalcFuelTransformByAvtoNo
  (FREQ NUMBER, p_CarNumber IN NVARCHAR2)
   RETURN NUMBER;

FUNCTION FuelThinOut
  (x SYNCH_WL."TMonPosTable", delayInMinutes NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelThinOutBySpeed
  (x SYNCH_WL."TMonPosTable", speed NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelThinBack
  (x SYNCH_WL."TMonPosTable", delayInMinutes NUMBER, dx NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelThinForward
  (x SYNCH_WL."TMonPosTable", delayInMinutes NUMBER, dx NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelMedianFilter
  (x SYNCH_WL."TMonPosTable", windowSize NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelAperiodicSmoothingForward
  (x SYNCH_WL."TMonPosTable", k NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelAperiodicSmoothingBackward
  (x SYNCH_WL."TMonPosTable", k NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelAperiodicSmoothing
  (x SYNCH_WL."TMonPosTable", k NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelDigitalFilter
  (x SYNCH_WL."TMonPosTable", dxPositive NUMBER, dxNegative NUMBER)
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelDeleteZeroFreqFilter
  (x SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TMonPosTable";

FUNCTION FuelLoading
  (original IN SYNCH_WL."TMonPosTable", filtered IN SYNCH_WL."TMonPosTable", dx IN NUMBER := 0)
   RETURN SYNCH_WL."TFuelLoadingIntervalTable";

FUNCTION FuelDraining
  (original IN SYNCH_WL."TMonPosTable", filtered IN SYNCH_WL."TMonPosTable", dx IN NUMBER := 10)
   RETURN SYNCH_WL."TFuelLoadingIntervalTable";

FUNCTION FuelFindLoadingWay1
  (x IN SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TFuelLoadingIntervalTable";

FUNCTION FuelFindLoadingWay2
  (x IN SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TFuelLoadingIntervalTable";

FUNCTION FuelFindDrainWay1
  (x IN SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TFuelLoadingIntervalTable";

FUNCTION MonPosTableToXml(x SYNCH_WL."TMonPosTable")
   RETURN XMLTYPE;

FUNCTION MonPosTableToXmlClob(x SYNCH_WL."TMonPosTable")
   RETURN CLOB;

FUNCTION FuelLoadingTableToXml(x SYNCH_WL."TFuelLoadingIntervalTable")
   RETURN XMLTYPE;

FUNCTION FuelLoadingTableToXmlClob(x SYNCH_WL."TFuelLoadingIntervalTable")
   RETURN CLOB;

FUNCTION GetTransformationToXml(p_CarNumber IN NVARCHAR2)
   RETURN XMLTYPE;

FUNCTION GetTransformationToXmlClob(p_CarNumber IN NVARCHAR2)
   RETURN CLOB;
   
FUNCTION GetGpsFaultByObjId(OBJ_ID IN NUMBER, BEGINDATE IN DATE, ENDDATE IN DATE)
  RETURN NUMBER;
   
FUNCTION GetGpsFault(AVTO_NO IN NVARCHAR2, BEGINDATE IN DATE, ENDDATE IN DATE)
  RETURN NUMBER;

-- GET STK DATA

PROCEDURE get_stk_data
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE);

PROCEDURE get_stk_data_gps
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   p_IMP_GPSFAULT OUT NUMBER);
   
PROCEDURE get_stk_data_detail
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   DETAIL OUT VARCHAR2);
   
PROCEDURE get_stk_data_detail_gps
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   DETAIL OUT VARCHAR2,
   p_IMP_GPSFAULT OUT NUMBER);
   
PROCEDURE get_stk_data_fuel
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   p_FUEL_OnRegDate OUT NUMBER,
   p_FUEL_OnReturnDate OUT NUMBER);
   
PROCEDURE get_stk_data_fuel_gps
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   p_FUEL_OnRegDate OUT NUMBER,
   p_FUEL_OnReturnDate OUT NUMBER,
   p_IMP_GPSFAULT OUT NUMBER);
   
PROCEDURE get_fuel_sensor_vehicles
  (p_Response OUT VARCHAR2);

PROCEDURE get_stk_data_fuel_xml
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_Response OUT VARCHAR2);

END;
CREATE OR REPLACE PACKAGE BODY "SYNCH_WL"."WL_PROC" IS

-- Supporting funtions

FUNCTION TotalHours
  (BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER IS
BEGIN
  RETURN ABS(24 * (ENDDATE - BEGINDATE));
END;

FUNCTION ConvertAvtoNo
  (AVTO_NO IN NVARCHAR2)
  RETURN NVARCHAR2 IS
BEGIN
  IF (AVTO_NO IS NULL) THEN
		RETURN '';
  END IF;
  RETURN LOWER(TRIM(REPLACE(REPLACE(AVTO_NO, ' ', ''), '-', '')));
END;

FUNCTION NumberArrayToString
  (NumberArray IN TNumberArray,
   Separator IN NVARCHAR2 := ';')
  RETURN NVARCHAR2 IS

    arrayLength NUMBER;
    vValue CHAR(20);
    j INTEGER;
    RESULT NVARCHAR2(500);
BEGIN
  arrayLength := NumberArray.COUNT;
  IF(arrayLength = 0) THEN
    RETURN '';
  END IF;

  RESULT := '';
  j := 0;
  LOOP
    j := j + 1;
    vValue := TO_CHAR(NumberArray(j), '0000000000.0000');
    RESULT := RESULT || vValue || Separator;

    EXIT WHEN j = arrayLength;
  END LOOP;

  RETURN REPLACE(RESULT, ' ', '');
END;


FUNCTION IntArrayToString
  (IntArray IN TNumberArray,
   Separator IN NVARCHAR2 := ';')
  RETURN NVARCHAR2 IS

    arrayLength NUMBER;
    vValue CHAR(20);
    j INTEGER;
    RESULT NVARCHAR2(500);
BEGIN
  arrayLength := IntArray.COUNT;
  IF(arrayLength = 0) THEN
    RETURN '';
  END IF;

  RESULT := '';
  j := 0;
  LOOP
    j := j + 1;
    vValue := TO_CHAR(IntArray(j), '0');
    RESULT := RESULT || vValue || Separator;

    EXIT WHEN j = arrayLength;
  END LOOP;

  RETURN REPLACE(RESULT, ' ', '');
END;

FUNCTION StringArrayToString
  (StringArray IN TStringArray,
   Separator IN NVARCHAR2 := ';')
  RETURN NVARCHAR2 IS

    arrayLength NUMBER;
    j INTEGER;
    RESULT NVARCHAR2(500);
BEGIN
  arrayLength := StringArray.COUNT;
  IF(arrayLength = 0) THEN
    RETURN '';
  END IF;

  RESULT := '';
  j := 0;
  LOOP
    j := j + 1;
    RESULT := RESULT || StringArray(j) || Separator;

    EXIT WHEN j = arrayLength;
  END LOOP;

  RETURN RESULT;
END;

FUNCTION DetailDataArrayToString
  (NAME_ARRAY IN TStringArray,
   MOTO_TYPE_ARRAY IN TNumberArray,
   MOTO_ARRAY IN TNumberArray,
   MOTO_COUNT_ARRAY IN TNumberArray,
   FUEL_ARRAY IN TNumberArray,
   ADDRESS_ARRAY IN TStringArray)
  RETURN NVARCHAR2 IS

    Detail NVARCHAR2(5000);
    Separator NVARCHAR2(2) := '|';--'#10';
BEGIN
  Detail := 'Name=' || StringArrayToString(NAME_ARRAY) || Separator;
  Detail := Detail || 'MotoType=' || IntArrayToString(MOTO_TYPE_ARRAY) || Separator;
  Detail := Detail || 'Moto=' || NumberArrayToString(MOTO_ARRAY) || Separator;
  Detail := Detail || 'MotoCount=' || NumberArrayToString(MOTO_COUNT_ARRAY) || Separator;
  Detail := Detail || 'Fuel=' || NumberArrayToString(FUEL_ARRAY) || Separator;
  Detail := Detail || 'Address=' || StringArrayToString(ADDRESS_ARRAY) || Separator;
  RETURN Detail;
END;

FUNCTION GetMonPosTable
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN SYNCH_WL."TMonPosTable" IS

    MonPosCursor TMonPosCursor;
    MainTable SYNCH_WL."TMonPosTable";
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN NULL;
  END IF;

  OPEN MonPosCursor FOR
    SELECT * FROM MONUSER.MONPOS
    WHERE
      (MONUSER.MONPOS.OBJID = OBJ_ID) AND
      (MONUSER.MONPOS.GMT >= TO_GMT(BEGINDATE)) AND
      (MONUSER.MONPOS.GMT <= TO_GMT(ENDDATE));

  MainTable := GetMonPosTableC(MonPosCursor);
  CLOSE MonPosCursor;
  RETURN MainTable;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
END;

FUNCTION GetMonPosTableC
  (MonPosCursor TMonPosCursor)
  RETURN SYNCH_WL."TMonPosTable" IS

    MonPosTable SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
    MonPosRow MONUSER.MONPOS%ROWTYPE;
    fuel_freq NUMBER;
    speed NUMBER;
BEGIN
  IF(NOT(MonPosCursor%ISOPEN)) THEN
    RETURN NULL;
  END IF;

  LOOP
    FETCH MonPosCursor INTO MonPosRow;
    EXIT WHEN MonPosCursor%NOTFOUND;

    fuel_freq := MonPosRow.FUEL;
    speed := MonPosRow.SPEED;
    IF ((fuel_freq IS NULL) OR (fuel_freq > MAX_FUEL_FREQ)) THEN
        fuel_freq := 0.0;
    END IF;
    IF (speed IS NULL) THEN
        speed := 0.0;
    END IF;

    MonPosTable.EXTEND;
    MonPosTable(MonPosTable.COUNT) := SYNCH_WL."TMonPos"(MonPosRow.OBJID,
      MonPosRow.GMT, MonPosRow.EVGMT, MonPosRow.FORMAT, MonPosRow.STATE,
      MonPosRow.LAT, MonPosRow.LON, speed, MonPosRow.DIST, MonPosRow.INPUT, fuel_freq);
  END LOOP;

  RETURN MonPosTable;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
END;

FUNCTION GetParamsFromMonPosTable
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   ObjIdArray OUT TNumberArray,
   BEGINDATE OUT DATE,
   ENDDATE OUT DATE)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;
    OBJ_ID NUMBER;
    j INTEGER;

    BeginDateGmt DATE;
    EndDateGmt DATE;
BEGIN
  IF((MonPosTable IS NULL) OR (MonPosTable.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  OPEN t_tablerow FOR
    SELECT DISTINCT OBJID FROM TABLE(CAST(MonPosTable AS SYNCH_WL."TMonPosTable"));

  j := 1;
  LOOP
    FETCH t_tablerow INTO OBJ_ID;
    EXIT WHEN t_tablerow%NOTFOUND;
    ObjIdArray(j) := OBJ_ID;
    j := j + 1;
  END LOOP;

  SELECT MIN(GMT), MAX(GMT) INTO BeginDateGmt, EndDateGmt
    FROM TABLE(CAST(MonPosTable AS SYNCH_WL."TMonPosTable"));

  IF((BEGINDATE IS NULL) OR (ENDDATE IS NULL)) THEN
    RETURN CRESULT_NOTFOUND;
  ELSE
    BEGINDATE := TO_EVGMT(BeginDateGmt);
    ENDDATE := TO_EVGMT(EndDateGmt);
  END IF;

  RETURN CRESULT_SUCCESS;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

PROCEDURE LOG_STK
  (DB_BEGIN IN DATE,
   DT_END IN DATE,
   AVTO_NO IN NVARCHAR2,
   OBJ_ID IN NUMBER,
   R_MOTO IN NUMBER,
   R_DIST IN NUMBER,
   S_DETAIL IN NVARCHAR2) IS
BEGIN
  INSERT
    INTO SYNCH_WL.GET_STK_DATA_LOG
      (SYNCH_WL.GET_STK_DATA_LOG.NOW,
       SYNCH_WL.GET_STK_DATA_LOG.DTBEGIN, SYNCH_WL.GET_STK_DATA_LOG.DTEND,
       SYNCH_WL.GET_STK_DATA_LOG.AVTONO, SYNCH_WL.GET_STK_DATA_LOG.OBJID,
       SYNCH_WL.GET_STK_DATA_LOG.MOTO, SYNCH_WL.GET_STK_DATA_LOG.DIST,
       SYNCH_WL.GET_STK_DATA_LOG.DETAIL)
      VALUES (SYSDATE, DB_BEGIN, DT_END, AVTO_NO, OBJ_ID, R_MOTO, R_DIST, S_DETAIL);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

FUNCTION TO_GMT
  (EVGMT IN DATE)
  RETURN DATE IS

    v_localts   TIMESTAMP WITH TIME ZONE;
    R DATE;
BEGIN
  IF (EVGMT IS NOT NULL) THEN
    v_localts := FROM_TZ(CAST(EVGMT AS TIMESTAMP), 'Europe/Moscow') AT TIME ZONE 'Greenwich';
    R := TO_DATE(TO_CHAR(v_localts,'YYYY-MM-DD HH24:MI:SS'),'YYYY-MM-DDHH24:MI:SS');

    IF ((IS_CORRECT_DATETIME() = 0) AND (EVGMT >= TO_DATE('2011.10.01 00:00:00','YYYY-MM-DD HH24:MI:SS')) AND (IS_EVGMT_WINTER_TIME(EVGMT) = 1)) THEN
        RETURN R - 1/24;
    END IF;

    RETURN R;
  END IF;
  RETURN EVGMT;
END;

FUNCTION TO_EVGMT
  (GMT IN DATE)
  RETURN DATE IS

    dt VARCHAR(100);
    v_localts   TIMESTAMP WITH TIME ZONE;
    R DATE;
BEGIN
  IF (GMT IS NOT NULL) THEN
    v_localts := FROM_TZ(CAST(GMT AS TIMESTAMP), 'Greenwich') AT TIME ZONE 'Europe/Moscow';
    R := TO_DATE(TO_CHAR(v_localts,'YYYY-MM-DD HH24:MI:SS'),'YYYY-MM-DDHH24:MI:SS');

    IF ((IS_CORRECT_DATETIME() = 0) AND (GMT >= TO_DATE('2011.10.01 00:00:00','YYYY-MM-DD HH24:MI:SS')) AND (IS_GMT_WINTER_TIME(GMT) = 1)) THEN
        RETURN R + 1/24;
    END IF;

    RETURN R;
  END IF;
  RETURN GMT;
END;

FUNCTION IS_GMT_WINTER_TIME
  (GMT IN DATE)
  RETURN NUMBER IS

    v_localts   TIMESTAMP WITH TIME ZONE;
BEGIN
  IF (GMT IS NOT NULL) THEN
    v_localts := FROM_TZ(CAST(GMT AS TIMESTAMP), 'Greenwich') AT TIME ZONE 'Europe/Moscow';
    IF(EXTRACT(TIMEZONE_ABBR FROM v_localts) = 'MSK') THEN
        RETURN 1;
    END IF;
  END IF;
  RETURN 0;
END;

FUNCTION IS_EVGMT_WINTER_TIME
  (EVGMT IN DATE)
  RETURN NUMBER IS
BEGIN
  IF (EVGMT IS NOT NULL) THEN
    IF(EXTRACT(TIMEZONE_ABBR FROM FROM_TZ(CAST(EVGMT AS TIMESTAMP), 'Europe/Moscow')) = 'MSK') THEN
        RETURN 1;
    END IF;
  END IF;
  RETURN 0;
END;

FUNCTION IS_CORRECT_DATETIME
    RETURN NUMBER IS

    v_localts   TIMESTAMP WITH TIME ZONE;
    R DATE;
BEGIN
    R := TO_DATE('2012-01-01 10:00:00','YYYY-MM-DDHH24:MI:SS');
    v_localts := FROM_TZ(CAST(R AS TIMESTAMP), 'Greenwich') AT TIME ZONE 'Europe/Moscow';
    R := TO_DATE(TO_CHAR(v_localts,'YYYY-MM-DD HH24:MI:SS'),'YYYY-MM-DDHH24:MI:SS');
    IF (TO_CHAR(R, 'YYYY-MM-DD HH24:MI:SS') = '2012-01-01 14:00:00') THEN
        RETURN 1;
    END IF;
    RETURN 0;
END;

-- Common functions
FUNCTION GetObjIdByAvtoNo
  (AVTONO IN NVARCHAR2)
  RETURN NUMBER IS

    OBJ_ID NUMBER;
BEGIN
  SELECT MONUSER.MONOBJ.OBJID
    INTO OBJ_ID
    FROM MONUSER.MONOBJ
    WHERE
      (MONUSER.MONOBJ.AVTO_NO IS NOT NULL) AND
      (MONUSER.MONOBJ.OBJID IS NOT NULL) AND
      (ConvertAvtoNo(MONUSER.MONOBJ.AVTO_NO) = ConvertAvtoNo(AVTONO)) AND
      (ROWNUM = 1);

  RETURN OBJ_ID;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN CRESULT_NOTFOUND;
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetAvtoNoByObjId
  (OBJ_ID IN NUMBER)
  RETURN NVARCHAR2 IS

    AVTONO NVARCHAR2(20);
BEGIN
  SELECT MONUSER.MONOBJ.AVTO_NO
    INTO AVTONO
    FROM MONUSER.MONOBJ
    WHERE
      (MONUSER.MONOBJ.AVTO_NO IS NOT NULL) AND
      (MONUSER.MONOBJ.OBJID IS NOT NULL) AND
      (MONUSER.MONOBJ.OBJID = OBJ_ID) AND
      (ROWNUM = 1);

  RETURN AVTONO;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
END;

FUNCTION IsDSTAvtoByAvtoNo
  (AVTO_NO IN NVARCHAR2)
  RETURN NUMBER IS

    STR NVARCHAR2(20);
BEGIN
  STR := ConvertAvtoNo(AVTO_NO);
  STR := REPLACE(STR, '0', '');
  STR := REPLACE(STR, '1', '');
  STR := REPLACE(STR, '2', '');
  STR := REPLACE(STR, '3', '');
  STR := REPLACE(STR, '4', '');
  STR := REPLACE(STR, '5', '');
  STR := REPLACE(STR, '6', '');
  STR := REPLACE(STR, '7', '');
  STR := REPLACE(STR, '8', '');
  STR := REPLACE(STR, '9', '');
  IF (LENGTH(STR) = 2) THEN
    RETURN 1; -- is DST
  END IF;
  RETURN 0; -- is not DST
END;

FUNCTION GetAddress
  (LAT IN NUMBER,
   LON IN NUMBER)
  RETURN NVARCHAR2 IS

    Addr NVARCHAR2(300);
    AddrCoord NVARCHAR2(300);
BEGIN
  AddrCoord := TO_CHAR(LAT, '000.00000000') || '-' || TO_CHAR(LON, '000.00000000');

  SELECT SYNCH_WL.ADDRESS.ADDRESS INTO Addr
  FROM SYNCH_WL.ADDRESS
  WHERE
  (
    (LAT >= SYNCH_WL.ADDRESS.LAT1) AND
    (LAT <= SYNCH_WL.ADDRESS.LAT2) AND
    (LON >= SYNCH_WL.ADDRESS.LON1) AND
    (LON <= SYNCH_WL.ADDRESS.LON2) AND
    (ROWNUM = 1)
  );

  RETURN Addr;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN AddrCoord;
    WHEN OTHERS THEN
     RETURN '';
END;

-- DIST

FUNCTION CalcDistByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER IS

    OBJ_ID NUMBER;
BEGIN
  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RETURN CalcDistByObjId(OBJ_ID, BEGINDATE, ENDDATE);

  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDistByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, BEGINDATE, ENDDATE);
  RETURN CalcDistByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE);

  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDistByObjIdC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  IF((OBJ_ID < 0) OR (NOT(MonPosCursor%ISOPEN))) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTableC(MonPosCursor);
  RETURN CalcDistByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDistByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    m_DIST NUMBER;
BEGIN
  IF((OBJ_ID < 0) OR (MonPosTable IS NULL)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  SELECT
    SUM(DIST - p_Dist) INTO m_DIST
    FROM
    (
      SELECT
        GMT, DIST, LAG(DIST) OVER (ORDER BY GMT) p_dist
      FROM
        TABLE(CAST(MonPosTable AS SYNCH_WL."TMonPosTable"))
      WHERE
      (
        (OBJID = OBJ_ID) AND
        (DIST IS NOT NULL) AND
        (GMT >= TO_GMT(BEGINDATE)) AND
        (GMT <= TO_GMT(ENDDATE)) AND
        (UTL_RAW.BIT_AND(FORMAT, CFORMAT_TIME_AND_PATH) = CFORMAT_TIME_AND_PATH)
      )
      ORDER BY GMT
    )
    WHERE (DIST > p_dist);

  IF(m_DIST IS NULL) THEN
    RETURN -1.0;
  END IF;

  RETURN m_DIST;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN -1.0;
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

FUNCTION GR_DIST_GEO
  (X_LAT NUMBER,
   X_LON NUMBER,
   Y_LAT NUMBER,
   Y_LON NUMBER)
  RETURN NUMBER IS

  R NUMBER;
  C NUMBER;
  s1 NUMBER;
  s2 NUMBER;
  t1 NUMBER;
  t2 NUMBER;
  L NUMBER;
  ac NUMBER;
BEGIN
  R := 6371.2;
  C := 3.14159265359 / 180.0;
  s1 := X_LON;
  t1 := X_LAT;
  s2 := Y_LON;
  t2 := Y_LAT;

  s1 := s1 * C;
  t1 := t1 * C;
  s2 := s2 * C;
  t2 := t2 * C;
  ac := COS(t1) * COS(t2) * COS(s2 - s1) + SIN(t1) * SIN(t2);
  IF(ac > 1.0) THEN
    ac := 1.0;
  END IF;
  IF(ac < -1.0) THEN
    ac := -1.0;
  END IF;
  L := R * ACOS(ac);
  RETURN L;
END;

FUNCTION GR_DITS_DURSHIN
  (X_LAT NUMBER,
   X_LON NUMBER,
   Y_LAT NUMBER,
   Y_LON NUMBER)
  RETURN NUMBER IS

  c_gps_pi NUMBER(29, 15) := 3.1415926535898;
  c_r_earth NUMBER(29, 15) := 637100000;
  v_arg NUMBER(29, 15);
BEGIN
  v_arg := c_gps_pi * c_r_earth / 180;
  RETURN SQRT(POWER((Y_LAT - X_LAT) * v_arg, 2) +
         POWER((Y_LON - X_LON) * v_arg * COS((X_LAT + Y_LAT) * c_gps_pi / 360), 2)) / 100000;
END;

FUNCTION CalcGEODistByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    OBJ_ID NUMBER;
    DIST NUMBER;
BEGIN
  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;
  OPEN t_tablerow FOR
    'SELECT SUM(SYNCH_WL.WL_PROC.GR_DIST_GEO(LAT, LON, p_LAT, p_LON)) FROM
       (
         SELECT
           GMT, LAT, LON,
           LAG(LAT) OVER (ORDER BY GMT) p_LAT,
           LAG(LON) OVER (ORDER BY GMT) p_LON
         FROM MONUSER.MONPOS
         WHERE
         (
           (OBJID = :OBJ_ID)
           AND (LAT IS NOT NULL)
           AND (LON IS NOT NULL)
           AND (GMT >= :BEGINDATE)
           AND (GMT <= :ENDDATE)
           AND (UTL_RAW.BIT_AND(FORMAT, :FORMAT) = :FORMAT)
         )
         ORDER BY GMT
       ) WHERE ((p_LAT is not null) AND (p_LON is not null))'
    USING OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE), CFORMAT_LAT_LON, CFORMAT_LAT_LON;

  FETCH t_tablerow INTO DIST;
  IF (DIST IS NULL) THEN
    DIST := 0.0;
  END IF;
  RETURN DIST;

  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDurshinDistByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    OBJ_ID NUMBER;
    DIST NUMBER;
BEGIN
  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;
  OPEN t_tablerow FOR
    'SELECT SUM(SYNCH_WL.WL_PROC.GR_DITS_DURSHIN(LAT, LON, p_LAT, p_LON)) FROM
       (
         SELECT
           GMT, LAT, LON,
           LAG(LAT) OVER (ORDER BY GMT) p_LAT,
           LAG(LON) OVER (ORDER BY GMT) p_LON
         FROM MONUSER.MONPOS
         WHERE
         (
           (MONUSER.MONPOS.OBJID = :OBJ_ID)
           AND (LAT IS NOT NULL)
           AND (LON IS NOT NULL)
           AND (GMT >= :BEGINDATE)
           AND (GMT <= :ENDDATE)
           AND (UTL_RAW.BIT_AND(FORMAT, :FORMAT) = :FORMAT)
         )
         ORDER BY GMT
       ) WHERE ((p_LAT is not null) AND (p_LON is not null))'
    USING OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE), CFORMAT_LAT_LON, CFORMAT_LAT_LON;

  FETCH t_tablerow INTO DIST;
  IF (DIST IS NULL) THEN
    DIST := 0.0;
  END IF;
  RETURN DIST;

  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

-- Moto

FUNCTION InsertUpdateDSTMask
  (MASK_NAME IN NVARCHAR2,
   FUEL_CONSUMPTION IN NUMBER,
   MASK IN RAW,
   MASK_DESCRIPTION IN NVARCHAR2 := '',
   SPEED_CONDITION_FLAG IN CHAR := NULL,
   SPEED_CONDITION IN NUMBER := 0.0,
   STATE_MASK IN RAW := HEXTORAW('00000000'),
   ADDRESS_ENABLED IN NUMBER := 1,
   COUNT_MODE IN NUMBER := 0,
   ALGORITHM_MASK IN RAW := HEXTORAW('00000000000000000000000000000000'))
  RETURN NUMBER IS

  MaskCount NUMBER;
BEGIN
  SELECT COUNT(*)
    INTO MaskCount
    FROM SYNCH_WL.ADD_EQUIPMENT
    WHERE SYNCH_WL.ADD_EQUIPMENT.NAME = MASK_NAME;

  IF (MaskCount > 0) THEN
    UPDATE SYNCH_WL.ADD_EQUIPMENT
      SET
       SYNCH_WL.ADD_EQUIPMENT.FUELCONSUMPTION = FUEL_CONSUMPTION,
       SYNCH_WL.ADD_EQUIPMENT.INPUTMASK = MASK,
       SYNCH_WL.ADD_EQUIPMENT.DESCRIPTION = MASK_DESCRIPTION,
       SYNCH_WL.ADD_EQUIPMENT.SPEEDCONDITIONFLAG = SPEED_CONDITION_FLAG,
       SYNCH_WL.ADD_EQUIPMENT.SPEEDCONDITION = SPEED_CONDITION,
       SYNCH_WL.ADD_EQUIPMENT.STATEMASK = STATE_MASK,
       SYNCH_WL.ADD_EQUIPMENT.ADDRESSENABLED = ADDRESS_ENABLED,
       SYNCH_WL.ADD_EQUIPMENT.COUNTMODE = COUNT_MODE,
       SYNCH_WL.ADD_EQUIPMENT.ALGORITHMMASK = ALGORITHM_MASK
      WHERE SYNCH_WL.ADD_EQUIPMENT.NAME = MASK_NAME;
  ELSE
    INSERT
      INTO SYNCH_WL.ADD_EQUIPMENT
      (SYNCH_WL.ADD_EQUIPMENT.NAME, SYNCH_WL.ADD_EQUIPMENT.FUELCONSUMPTION,
       SYNCH_WL.ADD_EQUIPMENT.INPUTMASK, SYNCH_WL.ADD_EQUIPMENT.DESCRIPTION,
       SYNCH_WL.ADD_EQUIPMENT.SPEEDCONDITIONFLAG, SYNCH_WL.ADD_EQUIPMENT.SPEEDCONDITION,
       SYNCH_WL.ADD_EQUIPMENT.STATEMASK, SYNCH_WL.ADD_EQUIPMENT.ADDRESSENABLED,
       SYNCH_WL.ADD_EQUIPMENT.COUNTMODE, SYNCH_WL.ADD_EQUIPMENT.ALGORITHMMASK)
      VALUES (MASK_NAME, FUEL_CONSUMPTION, MASK, MASK_DESCRIPTION,
        SPEED_CONDITION_FLAG, SPEED_CONDITION, STATE_MASK, ADDRESS_ENABLED,
        COUNT_MODE, ALGORITHM_MASK);
  END IF;
  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION DeleteDSTMask
  (MASK_NAME IN NVARCHAR2)
  RETURN NUMBER IS
BEGIN
  DELETE
    FROM SYNCH_WL.ADD_EQUIPMENT
    WHERE SYNCH_WL.ADD_EQUIPMENT.NAME = MASK_NAME;
  RETURN CRESULT_SUCCESS;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION AddMaskToTemplate
  (TEMPLATE_NAME IN NVARCHAR2,
   MASK_NAME IN NVARCHAR2)
   RETURN NUMBER IS

     C NUMBER;
BEGIN
  SELECT COUNT(*) INTO C
    FROM SYNCH_WL.ADD_EQUIPMENT_TEMPLATES
    WHERE
      (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.TEMPLATENAME = TEMPLATE_NAME) AND
      (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.ADD_EQUIPMENT_NAME = MASK_NAME);

  IF (C <> 0) THEN
    RETURN CRESULT_SUCCESS;
  END IF;

  SELECT COUNT(*) INTO C
    FROM SYNCH_WL.ADD_EQUIPMENT
    WHERE SYNCH_WL.ADD_EQUIPMENT.NAME = MASK_NAME;

  IF (C = 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  INSERT
    INTO SYNCH_WL.ADD_EQUIPMENT_TEMPLATES
      (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.TEMPLATENAME,
       SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.ADD_EQUIPMENT_NAME)
    VALUES (TEMPLATE_NAME, MASK_NAME);

  RETURN CRESULT_SUCCESS; -- SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION DelMaskFromTemplate
  (TEMPLATE_NAME IN NVARCHAR2,
   MASK_NAME IN NVARCHAR2)
   RETURN NUMBER IS

     C NUMBER;
BEGIN
  SELECT COUNT(*) INTO C
    FROM SYNCH_WL.ADD_EQUIPMENT_TEMPLATES
    WHERE
      (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.TEMPLATENAME = TEMPLATE_NAME) AND
      (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.ADD_EQUIPMENT_NAME = MASK_NAME);

  IF (C = 0) THEN
    RETURN CRESULT_SUCCESS;
  END IF;

  DELETE
    FROM SYNCH_WL.ADD_EQUIPMENT_TEMPLATES
    WHERE
      (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.TEMPLATENAME = TEMPLATE_NAME) AND
      (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.ADD_EQUIPMENT_NAME = MASK_NAME);

  RETURN CRESULT_SUCCESS; -- SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION AddDSTMaskToObjByObjId
  (MASK_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER IS

  MaskCount NUMBER;
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  SELECT COUNT(*)
    INTO MaskCount
    FROM SYNCH_WL.ADD_EQUIPMENT
    WHERE SYNCH_WL.ADD_EQUIPMENT.NAME = MASK_NAME;

  IF(MaskCount <> 1) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  SELECT COUNT(*)
    INTO MaskCount
    FROM SYNCH_WL.OBJ_ADD_EQUIPMENT
    WHERE
      (SYNCH_WL.OBJ_ADD_EQUIPMENT.ADD_EQUIPMENT_NAME = MASK_NAME) AND
      (SYNCH_WL.OBJ_ADD_EQUIPMENT.OBJID = OBJ_ID);

  IF(MaskCount = 0) THEN
    INSERT
      INTO SYNCH_WL.OBJ_ADD_EQUIPMENT
      (SYNCH_WL.OBJ_ADD_EQUIPMENT.OBJID,
       SYNCH_WL.OBJ_ADD_EQUIPMENT.ADD_EQUIPMENT_NAME)
      VALUES (OBJ_ID, MASK_NAME);
  END IF;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION DelDSTMaskFromObjByObjId
  (MASK_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER IS
BEGIN
  DELETE
    FROM SYNCH_WL.OBJ_ADD_EQUIPMENT
    WHERE
      (SYNCH_WL.OBJ_ADD_EQUIPMENT.ADD_EQUIPMENT_NAME = MASK_NAME) AND
      (SYNCH_WL.OBJ_ADD_EQUIPMENT.OBJID = OBJ_ID);

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION AddTemplateToObjByObjId
  (TEMPLATE_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER IS
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  INSERT INTO SYNCH_WL.OBJ_ADD_EQUIPMENT
    (SYNCH_WL.OBJ_ADD_EQUIPMENT.OBJID, SYNCH_WL.OBJ_ADD_EQUIPMENT.ADD_EQUIPMENT_NAME)
    (
      SELECT OBJ_ID, ADD_EQUIPMENT_NAME
      FROM SYNCH_WL.ADD_EQUIPMENT_TEMPLATES
      WHERE
      (
        (SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.TEMPLATENAME = TEMPLATE_NAME) AND
        (
          SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.ADD_EQUIPMENT_NAME NOT IN
          (
            SELECT SYNCH_WL.OBJ_ADD_EQUIPMENT.ADD_EQUIPMENT_NAME
              FROM SYNCH_WL.OBJ_ADD_EQUIPMENT
              WHERE SYNCH_WL.OBJ_ADD_EQUIPMENT.OBJID =OBJ_ID
          )
        )
      )
    );

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN CRESULT_NOTFOUND;
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION ReplaceTemplateToObjByObjId
  (TEMPLATE_NAME IN NVARCHAR2,
   OBJ_ID NUMBER)
  RETURN NUMBER IS

    TemplateCount NUMBER;
    RESULT NUMBER;
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  SELECT COUNT(*)
    INTO TemplateCount
    FROM SYNCH_WL.ADD_EQUIPMENT_TEMPLATES
    WHERE SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.TEMPLATENAME = TEMPLATE_NAME;

  IF(TemplateCount = 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := DelAllMasksFromObjByObjId(OBJ_ID);
  RESULT := AddTemplateToObjByObjId(TEMPLATE_NAME, OBJ_ID);

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN CRESULT_NOTFOUND;
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION AddTemplateToObjByAvtoNo
  (TEMPLATE_NAME IN NVARCHAR2,
   AVTO_NO IN NVARCHAR2)
  RETURN NUMBER IS

  OBJ_ID NUMBER;
BEGIN
  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;
  RETURN AddTemplateToObjByObjId(TEMPLATE_NAME, OBJ_ID);
END;

FUNCTION DeleteTemplate
  (TEMPLATE_NAME IN NVARCHAR2)
  RETURN NUMBER IS
BEGIN
  DELETE
    FROM SYNCH_WL.ADD_EQUIPMENT_TEMPLATES
    WHERE SYNCH_WL.ADD_EQUIPMENT_TEMPLATES.TEMPLATENAME = TEMPLATE_NAME;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION DelAllMasksFromObjByObjId
  (OBJ_ID IN NUMBER)
  RETURN NUMBER IS
BEGIN
  DELETE
    FROM SYNCH_WL.OBJ_ADD_EQUIPMENT
    WHERE SYNCH_WL.OBJ_ADD_EQUIPMENT.OBJID =OBJ_ID;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetDSTMaskByObjId
  (OBJ_ID IN NUMBER,
   AddEquipmentTable OUT TAddEquipmentTable)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    Mask RAW(16);
    FuelConsumption NUMBER(6,1);
    SpeedConditionFlag CHAR(2);
    SpeedCondition NUMBER;
    StateMask RAW(4);
    EquipmentName NVARCHAR2(50);
    AddressEnabled NUMBER(1,0);
    CountMode NUMBER(1,0);
    AlgorithmMask RAW(16);

    MaskIndex NUMBER;
BEGIN
  OPEN t_tablerow FOR
  'SELECT ADDRESSENABLED, COUNTMODE, INPUTMASK, FUELCONSUMPTION, SPEEDCONDITIONFLAG, SPEEDCONDITION, STATEMASK, NAME, ALGORITHMMASK
    FROM SYNCH_WL.ADD_EQUIPMENT WHERE SYNCH_WL.ADD_EQUIPMENT.NAME IN
      (SELECT ADD_EQUIPMENT_NAME FROM SYNCH_WL.OBJ_ADD_EQUIPMENT WHERE OBJID = :OBJ_ID)'
    USING OBJ_ID;

  MaskIndex := 1;
  LOOP
    FETCH t_tablerow INTO AddressEnabled, CountMode, Mask, FuelConsumption, SpeedConditionFlag, SpeedCondition, StateMask, EquipmentName, AlgorithmMask;
    EXIT WHEN t_tablerow%NOTFOUND;
    IF ((Mask IS NOT NULL) AND (FuelConsumption IS NOT NULL) AND (StateMask IS NOT NULL) ) THEN
      AddEquipmentTable(MaskIndex).INPUTMASK := Mask;
      AddEquipmentTable(MaskIndex).FUELCONSUMPTION := FuelConsumption;
      AddEquipmentTable(MaskIndex).SPEEDCONDITIONFLAG := SpeedConditionFlag;
      AddEquipmentTable(MaskIndex).SPEEDCONDITION := SpeedCondition;
      AddEquipmentTable(MaskIndex).STATEMASK := StateMask;
      AddEquipmentTable(MaskIndex).NAME := EquipmentName;
      AddEquipmentTable(MaskIndex).ADDRESSENABLED := AddressEnabled;
      AddEquipmentTable(MaskIndex).COUNTMODE := CountMode;
      AddEquipmentTable(MaskIndex).COUNTMODE := CountMode;

      IF(AlgorithmMask IS NOT NULL) THEN
        AddEquipmentTable(MaskIndex).ALGORITHMMASK := AlgorithmMask;
      ELSE
        AddEquipmentTable(MaskIndex).ALGORITHMMASK := HEXTORAW('00000000000000000000000000000000');
      END IF;

      MaskIndex := MaskIndex + 1;
    END IF;
  END LOOP;
  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDistByAcceleration
  (BEGIN_SPEED IN NUMBER,
   END_SPEED IN NUMBER,
   DT IN NUMBER)
  RETURN NUMBER IS

  A NUMBER;
BEGIN
  IF (DT = 0.0) THEN
    RETURN 0.0;
  END IF;
  A := (END_SPEED - BEGIN_SPEED) / DT;
  RETURN BEGIN_SPEED * DT + A * (DT * DT) / 2;
END;

FUNCTION CalcTimeInMovingByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   DIST OUT NUMBER)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;
BEGIN
  MOTO := 0.0;
  DIST := 0.0;
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;
  OPEN t_tablerow FOR
  -- SUM(SPEED * SYNCH_WL.WL_PROC.TotalHours(p_GMT, GMT))
 'SELECT
    SUM(SYNCH_WL.WL_PROC.TotalHours(p_GMT, GMT)),
    SUM(SYNCH_WL.WL_PROC.CalcDistByAcceleration(p_SPEED, SPEED, SYNCH_WL.WL_PROC.TotalHours(p_GMT, GMT)))
  FROM
  (
    SELECT
      SPEED,
      GMT,
      IsOn,
      LAG(GMT) OVER (ORDER BY GMT) p_GMT,
      LAG(IsOn) OVER (ORDER BY GMT) p_IsOn,
      LAG(SPEED) OVER (ORDER BY GMT) p_SPEED
    FROM
    (
      SELECT
        GMT,
        SPEED,
        CASE
        WHEN (SPEED > 0.0)
        THEN 1
        ELSE 0
        END as IsOn
      FROM
        MONUSER.MONPOS WHERE
        (
          (OBJID = :OBJ_ID) AND
          (GMT >= :BEGINDATE) AND
          (GMT <= :ENDDATE) AND
          (FORMAT is not null) AND
          (UTL_RAW.BIT_AND(MONUSER.MONPOS.FORMAT, :FORMAT) = :FORMAT) AND
          (SPEED is not null) AND
          (GMT is not null)
         )
      ORDER BY GMT
    )
  )
  WHERE
  (
    (GMT > p_GMT) AND
    (p_GMT is not null) AND
    (IsOn = 1) AND (p_IsOn = 1)
  )' USING OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE), CFORMAT_VELOCITY, CFORMAT_VELOCITY;

  FETCH t_tablerow INTO MOTO, DIST;
  IF (t_tablerow%NOTFOUND) THEN
    MOTO := 0.0;
    DIST := 0.0;
  END IF;
  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

FUNCTION AlgMaskToSQLCondition
  (PINPUT IN RAW,
   INPUT IN RAW,
   ALGORITHM_MASK IN RAW)
  RETURN RAW IS

    RESULT RAW(16);
    STRRESULT NVARCHAR2(32);
    ALG0 RAW(16);
    ALG1 RAW(16);
    ALG2 RAW(16);

    ALG_CHOICE_0 RAW(1) := HEXTORAW('00');
    ALG_CHOICE_1 RAW(1) := HEXTORAW('01');
    ALG_CHOICE_2 RAW(1) := HEXTORAW('02');

    ALG_BYTE RAW(1);
    OP_BYTE RAW(1);
    j INTEGER;
    diff_position INTEGER;
BEGIN
  IF ((PINPUT IS NULL) OR (INPUT IS NULL) OR (ALGORITHM_MASK IS NULL)) THEN
    RETURN HEXTORAW('00000000000000000000000000000000');
  END IF;

  ALG0 := PINPUT;
  ALG1 := UTL_RAW.BIT_XOR(PINPUT, INPUT);
  ALG2 := UTL_RAW.BIT_OR(PINPUT, INPUT);

  j := 0;
  STRRESULT := '';
  LOOP
    j := j + 1;

    ALG_BYTE := UTL_RAW.SUBSTR(ALGORITHM_MASK, j, 1);

    OP_BYTE := HEXTORAW('00');

    IF ((UTL_RAW.COMPARE(ALG_BYTE, ALG_CHOICE_0)) = 0) THEN
      OP_BYTE := UTL_RAW.SUBSTR(ALG0, j, 1);
    END IF;

    IF ((UTL_RAW.COMPARE(ALG_BYTE, ALG_CHOICE_1)) = 0) THEN
      OP_BYTE := UTL_RAW.SUBSTR(ALG1, j, 1);
    END IF;

    IF ((UTL_RAW.COMPARE(ALG_BYTE, ALG_CHOICE_2)) = 0) THEN
      OP_BYTE := UTL_RAW.SUBSTR(ALG2, j, 1);
    END IF;

    STRRESULT := STRRESULT || RAWTOHEX(OP_BYTE);

    EXIT WHEN j = 16; -- The SK cout is 16
  END LOOP;

  RESULT := HEXTORAW(STRRESULT);
  RETURN RESULT;
END;

FUNCTION MaskToSQLCondition
  (AddEquipmentItem IN SYNCH_WL.ADD_EQUIPMENT%ROWTYPE,
   IsAddressMode IN NUMBER := 0,
   CountModeControl IN NUMBER := 0)
   RETURN NVARCHAR2 IS
                                    -- CountModeControl:
                                    -- "1" - only if COUNT_MODE = 0 (disabled),
                                    -- "2" - only if COUNT_MODE = 1 (enabled)
                                    -- "0" - the both,
    vMaskItem NVARCHAR2(32);
    vStateMaskItem NVARCHAR2(8);
    vSpeedItem CHAR(20);
    SpeedFlagItem CHAR(2);
    IsAddressEnabled NUMBER(1,0);
    IsCountModeEnabled NUMBER(1,0);
    AlgMask NVARCHAR2(32);

    subMask NVARCHAR2(400);
    stateSubMask NVARCHAR2(400);
BEGIN
  vMaskItem := RAWTOHEX(AddEquipmentItem.INPUTMASK);
  vStateMaskItem := RAWTOHEX(AddEquipmentItem.STATEMASK);
  vSpeedItem := TO_CHAR(AddEquipmentItem.SPEEDCONDITION, '0000000000.0000');
  SpeedFlagItem := AddEquipmentItem.SPEEDCONDITIONFLAG;
  IsAddressEnabled := AddEquipmentItem.ADDRESSENABLED;
  IsCountModeEnabled := AddEquipmentItem.COUNTMODE;
  AlgMask := RAWTOHEX(AddEquipmentItem.ALGORITHMMASK);

  IF((IsAddressMode > 0) AND (IsAddressEnabled <= 0)) THEN
    RETURN '(1 <> 1)';  -- Ignore this mask
  END IF;

  IF((CountModeControl = 1) AND (IsCountModeEnabled > 0)) THEN
    RETURN '(1 <> 1)';  -- Ignore this mask
  END IF;

  IF((CountModeControl = 2) AND (IsCountModeEnabled <= 0)) THEN
    RETURN '(1 <> 1)';  -- Ignore this mask
  END IF;

  subMask := 'SYNCH_WL.WL_PROC.AlgMaskToSQLCondition(p_INPUT, INPUT, hextoraw(''' || AlgMask || '''))';
  subMask := '(UTL_RAW.BIT_AND(' || subMask || ', hextoraw(''' || vMaskItem || '''))';
  subMask := subMask || ' = hextoraw(''' || vMaskItem || '''))';

  stateSubMask := '(';
  IF ((vStateMaskItem IS NOT NULL) AND (vStateMaskItem <> '00000000')) THEN
    stateSubMask := stateSubMask || '(UTL_RAW.BIT_AND(STATE, hextoraw(''' || vStateMaskItem || '''))';
    stateSubMask := stateSubMask || ' = hextoraw(''' || vStateMaskItem || '''))';
  ELSE
    stateSubMask := stateSubMask || '(1 = 1)';
  END IF;

  IF (SpeedFlagItem IS NOT NULL) THEN

    IF (SpeedFlagItem = CFLAG_GT) THEN
      stateSubMask := stateSubMask || 'AND (SPEED > ' || vSpeedItem ||')';
    END IF;

    IF (SpeedFlagItem = CFLAG_GE) THEN
      stateSubMask := stateSubMask || 'AND (SPEED >= ' || vSpeedItem ||')';
    END IF;

    IF (SpeedFlagItem = CFLAG_LT) THEN
      stateSubMask := stateSubMask || 'AND (SPEED < ' || vSpeedItem ||')';
    END IF;

    IF (SpeedFlagItem = CFLAG_LE) THEN
      stateSubMask := stateSubMask || 'AND (SPEED <= ' || vSpeedItem ||')';
    END IF;

    IF (SpeedFlagItem = CFLAG_NE) THEN
      stateSubMask := stateSubMask || 'AND (SPEED <> ' || vSpeedItem ||')';
    END IF;
  END IF;

  stateSubMask := stateSubMask || ')';
  RETURN '(' || subMask || ' AND ' || stateSubMask || ')';
END;

FUNCTION MaskArrayToSQLCondition
  (MaskArray IN TAddEquipmentTable,
   IsAddressMode IN NUMBER := 0,
   CountModeControl IN NUMBER := 0)
  RETURN NVARCHAR2 IS

    MaskCount INTEGER;
    subMask NVARCHAR2(1000);
    Mask NVARCHAR2(6000);

    MaskItem SYNCH_WL.ADD_EQUIPMENT%ROWTYPE;
    j INTEGER;
BEGIN
  MaskCount := MaskArray.COUNT;
  IF(MaskCount = 0) THEN
    RETURN '(1 <> 1)';
  END IF;

  Mask := '';
  j := 0;
  LOOP
    j := j + 1;

    MaskItem := MaskArray(j);

    subMask := MaskToSQLCondition(MaskItem, IsAddressMode, CountModeControl);

    Mask := Mask || '(' || subMask || ')';
    IF(j < MaskCount) THEN
      Mask := Mask || ' OR ';
    END IF;

    EXIT WHEN j = MaskCount;
  END LOOP;
  Mask := '(' || Mask || ')';

  RETURN Mask;
END;

FUNCTION MaskArrayToFuelSQLCondition
  (MaskArray IN TAddEquipmentTable,
   CountModeControl IN NUMBER := 0)
  RETURN NVARCHAR2 IS

    MaskCount INTEGER;
    subMask NVARCHAR2(1000);
    FuelString NVARCHAR2(6000);

    MaskItem SYNCH_WL.ADD_EQUIPMENT%ROWTYPE;
    FuelConsumption NUMBER(6,1);
    IsCountModeEnabled NUMBER(1,0);

    FuelConsumptionStr CHAR(20);
    j INTEGER;
BEGIN
  MaskCount := MaskArray.COUNT;
  IF(MaskCount = 0) THEN
    RETURN '';
  END IF;

  FuelString := '';
  j := 0;
  LOOP
    j := j + 1;

    MaskItem := MaskArray(j);
    FuelConsumption := MaskItem.FUELCONSUMPTION;
    FuelConsumptionStr := TO_CHAR(FuelConsumption, '0000000000.0000');
    IsCountModeEnabled := MaskItem.COUNTMODE;

    subMask := MaskToSQLCondition(MaskItem);

    IF(
        (CountModeControl = 0) OR
        ((CountModeControl = 1) AND (IsCountModeEnabled <= 0)) OR
        ((CountModeControl = 2) AND (IsCountModeEnabled > 0))
       ) THEN
      FuelString := FuelString || '(CASE WHEN ' || subMask || ' THEN ';
      FuelString := FuelString || FuelConsumptionStr || ' ELSE 0.0 END)';
    ELSE
      FuelString := '(0.0)';
    END IF;

    IF(j < MaskCount) THEN
      FuelString := FuelString || ' + ';
    END IF;

    EXIT WHEN j = MaskCount;
  END LOOP;
  FuelString := '(' || FuelString || ')';

  RETURN FuelString;
END;

FUNCTION CalcDSTMotoByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0,
   MotoCountMode IN NUMBER := 1)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  IF((OBJ_ID < 0) OR (MaskArray.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, BEGINDATE, ENDDATE);
  RETURN CalcDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray, MOTO, FUEL_CONSUMPTION, IsAddressMode, MotoCountMode);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDSTMotoByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0,
   MotoCountMode IN NUMBER := 1)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    Mask NVARCHAR2(3000);
    ModeConditionCount NVARCHAR2(100);
    ModeConditionFuel NVARCHAR2(100);
    FuelString NVARCHAR2(3000);
    sqlString VARCHAR2(6000);
BEGIN
  MOTO := 0.0;
  FUEL_CONSUMPTION := 0.0;

  IF((OBJ_ID < 0) OR (MonPosTable IS NULL) OR (MaskArray.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  Mask := MaskArrayToSQLCondition(MaskArray, IsAddressMode, MotoCountMode);
  FuelString := MaskArrayToFuelSQLCondition(MaskArray, MotoCountMode);

  IF (MotoCountMode = 2) THEN -- Count mode disabled
    ModeConditionCount := 'COUNT(GMT)';
    ModeConditionFuel := 'COUNT(GMT) * FuelConsumption)';
  ELSE -- Count mode only
    ModeConditionCount := 'SUM(SYNCH_WL.WL_PROC.TotalHours(p_GMT, GMT))';
    ModeConditionFuel := 'SUM(SYNCH_WL.WL_PROC.TotalHours(p_GMT, GMT) * FuelConsumption)';
  END IF;

  sqlString :=
  'SELECT
     ' || ModeConditionCount || ',
     ' || ModeConditionFuel || ' / 100.0
   FROM
   (
     SELECT GMT,
       LAG(GMT) OVER (ORDER BY GMT) p_GMT,
       CASE
         WHEN (' || Mask || ')
         THEN 1
         ELSE 0
       END as IsOn,
       (' || FuelString || ') as FuelConsumption
     FROM
     (
       SELECT
         GMT, OBJID, INPUT, STATE, FORMAT, SPEED,
         LAG(INPUT) OVER (ORDER BY GMT) p_INPUT
       FROM TABLE(CAST(:MonPosTable AS SYNCH_WL."TMonPosTable"))
       WHERE
       (
         (OBJID = :OBJ_ID) AND
         (GMT >= :BEGINDATE) AND
         (GMT <= :ENDDATE) AND
         (FORMAT is not null) AND
         (INPUT is not null) AND
         (GMT is not null) AND
         (UTL_RAW.BIT_AND(FORMAT, hextoraw(''' || CFORMAT_PORT_S || ''')) = hextoraw(''' || CFORMAT_PORT_S || '''))
       )
       ORDER BY GMT
     )
   )
   WHERE
   (
     (IsOn = 1)
   )';

  OPEN t_tablerow FOR sqlString USING MonPosTable, OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE);

  FETCH t_tablerow INTO MOTO, FUEL_CONSUMPTION;
  IF (t_tablerow%NOTFOUND) THEN
    MOTO := 0.0;
    FUEL_CONSUMPTION := 0;
  END IF;
  IF(MOTO IS NULL) THEN
    MOTO := 0.0;
  END IF;
  IF(FUEL_CONSUMPTION IS NULL) THEN
    FUEL_CONSUMPTION := 0.0;
  END IF;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcFullDSTMotoByObjId
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  MOTO := 0;
  FUEL_CONSUMPTION := 0;

  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, BEGINDATE, ENDDATE);
  RETURN CalcFullDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MOTO, FUEL_CONSUMPTION, IsAddressMode);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcFullDSTMotoByObjIdC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  MOTO := 0;
  FUEL_CONSUMPTION := 0;

  IF((OBJ_ID < 0) OR (NOT(MonPosCursor%ISOPEN))) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTableC(MonPosCursor);
  RETURN CalcFullDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MOTO, FUEL_CONSUMPTION, IsAddressMode);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcFullDSTMotoByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   IsAddressMode IN NUMBER := 0)
  RETURN NUMBER IS

    MaskArray TAddEquipmentTable;
    RESULT NUMBER;
BEGIN
  MOTO := 0;
  FUEL_CONSUMPTION := 0;

  IF((OBJ_ID < 0) OR (MonPosTable IS NULL)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF(RESULT < 0) THEN
    RETURN RESULT;
  END IF;

  IF((MaskArray IS NULL) OR (MaskArray.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := CalcDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
                                MOTO, FUEL_CONSUMPTION, IsAddressMode);

  IF(RESULT < CRESULT_SUCCESS) THEN
    RETURN RESULT;
  END IF;
  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDetailDSTMotoByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   AddEquipmentNames OUT VARCHAR2,
   MotoDetails OUT VARCHAR2,
   FuelConsumptionDetails OUT VARCHAR2)
  RETURN NUMBER IS

    MaskArray TAddEquipmentTable;

    RESULT NUMBER;
    OBJ_ID NUMBER;

    MotoArray TNumberArray;
    MotoCountArray TNumberArray;
    MotoTypeArray TNumberArray;
    FuelArray TNumberArray;
    AddressArray TStringArray;
    AddEquipmentNameArray TStringArray;
BEGIN
  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF(RESULT < 0) THEN
    RETURN RESULT;
  END IF;
  IF((MaskArray IS NULL) OR (MaskArray.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := GetWorkingPointMoto(OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
               AddEquipmentNameArray, MotoTypeArray, MotoArray, MotoCountArray,
               FuelArray, AddressArray, MOTO, FUEL_CONSUMPTION);

  IF(RESULT < 0) THEN
    RETURN RESULT;
  END IF;

  MotoDetails := NumberArrayToString(MotoArray);
  FuelConsumptionDetails := NumberArrayToString(FuelArray);
  AddEquipmentNames := StringArrayToString(AddEquipmentNameArray);

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDetailDSTMotoByObjIdT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MOTO OUT NUMBER,
   FUEL_CONSUMPTION OUT NUMBER,
   AddEquipmentNames OUT VARCHAR2,
   MotoDetails OUT VARCHAR2,
   FuelConsumptionDetails OUT VARCHAR2)
  RETURN NUMBER IS

    MaskArray TAddEquipmentTable;
    RESULT NUMBER;

    MotoArray TNumberArray;
    MotoCountArray TNumberArray;
    FuelArray TNumberArray;
    AddressArray TStringArray;
    MotoTypeArray TNumberArray;
    AddEquipmentNameArray TStringArray;
BEGIN
  IF((OBJ_ID < 0) OR (MonPosTable IS NULL)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF(RESULT < 0) THEN
    RETURN RESULT;
  END IF;
  IF((MaskArray IS NULL) OR (MaskArray.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := GetWorkingPointMotoT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
               AddEquipmentNameArray, MotoTypeArray, MotoArray, MotoCountArray,
               FuelArray, AddressArray, MOTO, FUEL_CONSUMPTION);

  IF(RESULT < 0) THEN
    RETURN RESULT;
  END IF;

  MotoDetails := NumberArrayToString(MotoArray);
  FuelConsumptionDetails := NumberArrayToString(FuelArray);
  AddEquipmentNames := StringArrayToString(AddEquipmentNameArray);

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcDetailDSTMotoByObjIdCT
  (MonPosCursor IN TMonPosCursor)
  RETURN SYNCH_WL."TWorkingPointTable" IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  IF (NOT(MonPosCursor%ISOPEN)) THEN
    RETURN NULL;
  END IF;

  MonPosTable := GetMonPosTableC(MonPosCursor);
  RETURN CalcDetailDSTMotoByObjIdTT(MonPosTable);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
END;

FUNCTION CalcDetailDSTMotoByObjIdTT
  (MonPosTable IN SYNCH_WL."TMonPosTable")
  RETURN SYNCH_WL."TWorkingPointTable" IS

    ObjIdArray TNumberArray;
    OBJ_ID NUMBER;
    BEGINDATE DATE;
    ENDDATE DATE;
    RESULT NUMBER;
    j INTEGER;
    WorkingTable SYNCH_WL."TWorkingPointTable" := SYNCH_WL."TWorkingPointTable"();

    MOTO NUMBER;
    FUEL_CONSUMPTION NUMBER;
    AddEquipmentNames VARCHAR2(300);
    MotoDetails VARCHAR2(300);
    FuelConsumptionDetails VARCHAR2(300);
BEGIN
  IF(MonPosTable IS NULL) THEN
    RETURN NULL;
  END IF;

  RESULT := GetParamsFromMonPosTable(MonPosTable, ObjIdArray, BEGINDATE, ENDDATE);
  IF((RESULT < 0) OR (ObjIdArray.COUNT = 0)) THEN
    RETURN NULL;
  END IF;

  j := 0;
  LOOP
    j := j + 1;
    OBJ_ID := ObjIdArray(j);

    RESULT := CalcDetailDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE,
       MOTO, FUEL_CONSUMPTION, AddEquipmentNames, MotoDetails, FuelConsumptionDetails);

    IF (RESULT >= 0) THEN
        WorkingTable.EXTEND;
        WorkingTable(WorkingTable.COUNT) := SYNCH_WL."TWorkingPoint"(
          BEGINDATE, ENDDATE, 0.0, 0.0, MOTO, FUEL_CONSUMPTION,
          AddEquipmentNames, MotoDetails, FuelConsumptionDetails);
    END IF;

    EXIT WHEN j = ObjIdArray.COUNT;
  END LOOP;

  RETURN WorkingTable;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
END;

-- Working X, Y Pos

FUNCTION FastBall
  (p_x IN TPointArray,
   p_y IN TPointArray,
   c_x OUT NUMBER,
   c_y OUT NUMBER)
  RETURN NUMBER IS

    rad NUMBER;
    rad2 NUMBER;                       -- radius and radius squared
    xmin NUMBER;
    xmax NUMBER;
    ymin NUMBER;
    ymax NUMBER;          -- bounding box extremes
    pXmin INTEGER;
    pXmax INTEGER;
    pYmin INTEGER;
    pYmax INTEGER;      -- index of V[] at box extreme
    dVx_x NUMBER;
    dVx_y NUMBER;
    dVy_x NUMBER;
    dVy_y NUMBER;
    dV_x NUMBER;
    dV_y NUMBER;
    dx2 NUMBER;
    dy2 NUMBER;
    rad0 NUMBER;
    rad02 NUMBER;
    dist NUMBER;
    dist2 NUMBER;
    I INTEGER;
BEGIN
  c_x := 0.0; -- Center of ball
  c_y := 0.0;

  IF((p_x IS NULL) OR (p_y IS NULL) OR (p_x.COUNT <> p_y.COUNT) OR (p_x.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  -- find a large diameter to start with
  -- first get the bounding box and V[] extreme points for it
  xmin := p_x(1);
  xmax := p_x(1);
  ymin := p_y(1);
  ymax := p_y(1);

  pXmin := 1;
  pXmax := 1;
  pYmin := 1;
  pYmax := 1;

  I := 1;
  LOOP
    IF (p_x(I) < xmin) THEN
      xmin := p_x(I);
      pXmin := I;
    ELSE
      IF (p_x(I) > xmax) THEN
        xmax := p_x(I);
        pXmax := I;
      END IF;
    END IF;
    IF(p_y(I) < ymin) THEN
      ymin := p_y(I);
      pYmin := I;
    ELSE
      IF (p_y(I) > ymax) THEN
        ymax := p_y(I);
        pYmax := I;
      END IF;
    END IF;
    EXIT WHEN (I = p_x.COUNT);
    I := I + 1;
  END LOOP;

  -- select the largest extent as an initial diameter for the ball
  dVx_x := p_x(pXmax) - p_x(pXmin); -- diff of Vx max and min
  dVx_y := p_y(pXmax) - p_y(pXmin);
  dVy_x := p_x(pYmax) - p_x(pYmin); -- diff of Vy max and min
  dVy_y := p_y(pYmax) - p_y(pYmin);

  dx2 := dVx_x * dVx_x + dVx_y * dVx_y; -- Vx diff squared
  dy2 := dVy_x * dVy_x + dVy_y * dVy_y; -- Vy diff squared
  IF (dx2 >= dy2) THEN -- x direction is largest extent
    c_x := p_x(pXmin) + (dVx_x / 2.0);   -- Center = midpoint of extremes
    c_y := p_y(pXmin) + (dVx_y / 2.0);
    rad02 := (p_x(pXmax) - c_x) * (p_x(pXmax) - c_x) + (p_y(pXmax) - c_y) * (p_y(pXmax) - c_y);  -- radius squared
  ELSE -- y direction is largest extent
    c_x := p_x(pYmin) + (dVy_x / 2.0);   -- Center = midpoint of extremes
    c_y := p_y(pYmin) + (dVy_y / 2.0);
    rad02 := (p_x(pYmax) - c_x) * (p_x(pYmax) - c_x) + (p_y(pYmax) - c_y) * (p_y(pYmax) - c_y);  -- radius squared
  END IF;
  rad0 := SQRT(rad02);

  -- now check that all points V[i] are in the ball
  -- and if not, expand the ball just enough to include them

  I := 1;
  LOOP
    dV_x := p_x(I) - c_x;
    dV_y := p_y(I) - c_y;

    dist2 := dV_x * dV_x + dV_y * dV_y;
    IF (dist2 > rad2) THEN  -- // if (dist2 <= rad2) V[i] is inside the ball already
      -- V[i] not in ball, so expand ball to include it
      dist := SQRT(dist2);
      rad0 := (rad0 + dist) / 2.0;         -- enlarge radius just enough
      rad02 := rad0 * rad0;
      c_x := c_x + ((dist - rad0) / dist) * dV_x; -- shift Center toward V[i]
      c_y := c_y + ((dist - rad0) / dist) * dV_y;
    END IF;

    EXIT WHEN (I = p_x.COUNT);
    I := I + 1;
  END LOOP;

  RETURN CRESULT_SUCCESS; -- SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION IsInCircle
  (X IN NUMBER,
   Y IN NUMBER,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER)
  RETURN NUMBER IS

    dX NUMBER;
    dY NUMBER;
BEGIN
  dX := X - CentreX;
  dY := Y - CentreY;
  IF(dX * dX + dY * dY <= Radius * Radius) THEN
    RETURN 1;
  END IF;
  RETURN 0;
END;

FUNCTION GetFirstWorkingPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  X := 0.0;
  Y := 0.0;

  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, BEGINDATE, ENDDATE);
  RETURN GetFirstWorkingPointT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray, X, Y, EVGMT);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetFirstWorkingPointC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  X := 0.0;
  Y := 0.0;

  IF((OBJ_ID < 0) OR (NOT(MonPosCursor%ISOPEN)) OR (MaskArray.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTableC(MonPosCursor);
  RETURN GetFirstWorkingPointT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray, X, Y, EVGMT);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetFirstWorkingPointT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    MaskCondition NVARCHAR2(3000);
    sqlString VARCHAR(6000);
    MaskCount INTEGER;
    GMT DATE;
BEGIN
  X := 0.0;
  Y := 0.0;

  IF((OBJ_ID < 0) OR (MonPosTable IS NULL) OR (MaskArray.COUNT = 0)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCondition := MaskArrayToSQLCondition(MaskArray, 1);

  sqlString :=
  'SELECT LAT, LON, GMT
   FROM
   (
     SELECT
       GMT, OBJID, INPUT, STATE, FORMAT, SPEED, LAT, LON,
       LAG(INPUT) OVER (ORDER BY GMT) p_INPUT
     FROM
     TABLE(CAST(:MonPosTable AS SYNCH_WL."TMonPosTable"))
     WHERE
     (
         (OBJID = :OBJ_ID) AND
         (GMT >= :BEGINDATE) AND
         (GMT <= :ENDDATE) AND
         (FORMAT is not null) AND
         (INPUT is not null) AND
         (LON is not null) AND
         (LAT is not null) AND
         (UTL_RAW.BIT_AND(FORMAT, hextoraw(''' || CFORMAT_PORT_S || ''')) = hextoraw(''' || CFORMAT_PORT_S || '''))
     )
     ORDER BY GMT
   )
   WHERE
     (' || MaskCondition || ') AND
     (rownum = 1)';

  OPEN t_tablerow FOR sqlString USING MonPosTable, OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE);
  FETCH t_tablerow INTO X, Y, GMT;

  IF (t_tablerow%NOTFOUND) THEN
    X := -1.0;
    Y := -1.0;
    RETURN CRESULT_NOTFOUND;
  ELSE
    EVGMT := TO_EVGMT(GMT);
  END IF;


  RETURN CRESULT_SUCCESS; --SUCCESS

  --EXCEPTION
  --  WHEN OTHERS THEN
  --    RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetNextWorkingPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  X := 0.0;
  Y := 0.0;

  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, BEGINDATE, ENDDATE);
  RETURN GetNextWorkingPointT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
            CentreX, CentreY, Radius, X, Y, EVGMT);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetNextWorkingPointT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   X OUT NUMBER,
   Y OUT NUMBER,
   EVGMT OUT DATE)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;
    CentreXStr CHAR(20);
    CentreYStr CHAR(20);
    RadiusStr CHAR(20);

    MaskCondition NVARCHAR2(3000);
    CircleCondition NVARCHAR2(3000);
    sqlString VARCHAR(6000);
    MaskCount INTEGER;

    GMT DATE;
BEGIN
  X := 0.0;
  Y := 0.0;

  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCount := MaskArray.COUNT;
  IF(MaskCount = 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCondition := MaskArrayToSQLCondition(MaskArray, 1);

  CentreXStr := TO_CHAR(CentreX, '0000000000.0000');
  CentreYStr := TO_CHAR(CentreY, '0000000000.0000');
  RadiusStr := TO_CHAR(Radius, '0000000000.0000');

  CircleCondition := '(SYNCH_WL.WL_PROC.IsInCircle(LAT, LON,';
  CircleCondition := CircleCondition || ' ' || CentreXStr || ',';
  CircleCondition := CircleCondition || ' ' || CentreYStr || ',';
  CircleCondition := CircleCondition || ' ' || RadiusStr || ') = 0)';

  sqlString :=
  'SELECT LAT, LON, GMT
   FROM
   (
     SELECT
       GMT, OBJID, INPUT, STATE, FORMAT, SPEED, LAT, LON,
       LAG(INPUT) OVER (ORDER BY GMT) p_INPUT
     FROM
     TABLE(CAST(:MonPosTable AS SYNCH_WL."TMonPosTable"))
     WHERE
     (
         (OBJID = :OBJ_ID) AND
         (GMT >= :BEGINDATE) AND
         (GMT <= :ENDDATE) AND
         (FORMAT is not null) AND
         (INPUT is not null) AND
         (LON is not null) AND
         (LAT is not null) AND
         (UTL_RAW.BIT_AND(FORMAT, hextoraw(''' || CFORMAT_PORT_S || ''')) = hextoraw(''' || CFORMAT_PORT_S || '''))
     )
     ORDER BY GMT
   )
   WHERE
   (
     (' || MaskCondition || ') AND
     (' || CircleCondition || ') AND
     (rownum = 1)
   )';

  OPEN t_tablerow FOR sqlString USING MonPosTable, OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE);
  FETCH t_tablerow INTO X, Y, GMT;

  IF (t_tablerow%NOTFOUND) THEN
    X := 0;
    Y := 0;
    RETURN CRESULT_NOTFOUND;
  ELSE
    EVGMT := TO_EVGMT(GMT);
  END IF;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetWorkingPointDate
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   BeginAt OUT DATE,
   EndAt OUT DATE)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, BEGINDATE, ENDDATE);
  RETURN GetWorkingPointDateT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
            CentreX, CentreY, Radius, BeginAt, EndAt);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetWorkingPointDateT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   BeginAt OUT DATE,
   EndAt OUT DATE)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;
    CentreXStr CHAR(20);
    CentreYStr CHAR(20);
    RadiusStr CHAR(20);

    MaskCondition NVARCHAR2(3000);
    CircleCondition NVARCHAR2(3000);
    sqlString VARCHAR(6000);
    MaskCount INTEGER;

    BeginAtGmt DATE;
    EndAtGmt DATE;
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCount := MaskArray.COUNT;
  IF(MaskCount = 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCondition := MaskArrayToSQLCondition(MaskArray, 1);

  CentreXStr := TO_CHAR(CentreX, '0000000000.0000');
  CentreYStr := TO_CHAR(CentreY, '0000000000.0000');
  RadiusStr := TO_CHAR(Radius, '0000000000.0000');

  CircleCondition := '(SYNCH_WL.WL_PROC.IsInCircle(LAT, LON,';
  CircleCondition := CircleCondition || ' ' || CentreXStr || ',';
  CircleCondition := CircleCondition || ' ' || CentreYStr || ',';
  CircleCondition := CircleCondition || ' ' || RadiusStr || ') = 1)';

  sqlString :=
  'SELECT BeginAt, EndAt
   FROM
   (
     SELECT
       FIRST_VALUE(GMT) OVER(ORDER BY GMT) as BeginAt,
       LAST_VALUE(GMT) OVER(ORDER BY GMT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as EndAt
     FROM
     (
       SELECT GMT, IsOn, LAG(IsOn) OVER(ORDER BY GMT) as p_IsOn
       FROM
       (
         SELECT GMT,
           CASE WHEN (' || CircleCondition || ') THEN 1 ELSE 0 END as IsOn
         FROM
         (
           SELECT
             GMT, OBJID, INPUT, STATE, FORMAT, SPEED, LAT, LON,
             LAG(INPUT) OVER (ORDER BY GMT) p_INPUT
           FROM
             TABLE(CAST(:MonPosTable AS SYNCH_WL."TMonPosTable"))
           WHERE
           (
             (OBJID = :OBJ_ID) AND
             (GMT >= :BEGINDATE) AND
             (GMT <= :ENDDATE) AND
             (FORMAT is not null) AND
             (INPUT is not null) AND
             (LON is not null) AND
             (LAT is not null) AND
             (UTL_RAW.BIT_AND(FORMAT, hextoraw(''' || CFORMAT_PORT_S || ''')) = hextoraw(''' || CFORMAT_PORT_S || '''))
           )
           ORDER BY GMT
         )
         WHERE
           (' || MaskCondition || ')
       )
     )
     WHERE ((IsOn = 1) AND ((p_IsOn = 1) OR (p_IsOn is null)))
   )
   WHERE (rownum = 1)';

  OPEN t_tablerow FOR sqlString USING MonPosTable, OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE);
  FETCH t_tablerow INTO BeginAtGmt, EndAtGmt;

  IF (t_tablerow%NOTFOUND) THEN
    RETURN CRESULT_NOTFOUND;
  ELSE
    BeginAt := TO_EVGMT(BeginAtGmt);
    EndAt := TO_EVGMT(EndAtGmt);
  END IF;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetWorkingPointCoordT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray TAddEquipmentTable,
   CentreX IN NUMBER,
   CentreY IN NUMBER,
   Radius IN NUMBER,
   p_x OUT TPointArray,
   p_y OUT TPointArray)
  RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;
    CentreXStr CHAR(20);
    CentreYStr CHAR(20);
    RadiusStr CHAR(20);

    MaskCondition NVARCHAR2(3000);
    CircleCondition NVARCHAR2(3000);
    sqlString VARCHAR(6000);
    MaskCount INTEGER;

    LAT NUMBER;
    LON NUMBER;

    I INTEGER;
BEGIN
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCount := MaskArray.COUNT;
  IF(MaskCount = 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCondition := MaskArrayToSQLCondition(MaskArray, 1);

  CentreXStr := TO_CHAR(CentreX, '0000000000.0000');
  CentreYStr := TO_CHAR(CentreY, '0000000000.0000');
  RadiusStr := TO_CHAR(Radius, '0000000000.0000');

  CircleCondition := '(SYNCH_WL.WL_PROC.IsInCircle(LAT, LON,';
  CircleCondition := CircleCondition || ' ' || CentreXStr || ',';
  CircleCondition := CircleCondition || ' ' || CentreYStr || ',';
  CircleCondition := CircleCondition || ' ' || RadiusStr || ') = 1)';

  sqlString :=
  'SELECT LAT, LON
   FROM
     TABLE(CAST(:MonPosTable AS SYNCH_WL."TMonPosTable"))
   WHERE
   (
     (OBJID = :OBJ_ID) AND
     (GMT >= :BEGINDATE) AND
     (GMT <= :ENDDATE) AND
     (FORMAT is not null) AND
     (INPUT is not null) AND
     (LAT is not null) AND
     (LON is not null) AND
     (UTL_RAW.BIT_AND(MONUSER.MONPOS.FORMAT, hextoraw(''' || CFORMAT_PORT_S || ''')) = hextoraw(''' || CFORMAT_PORT_S || ''')) AND
     (' || MaskCondition || ') AND
     (' || CircleCondition || ')
   )
   ORDER BY GMT';

  OPEN t_tablerow FOR sqlString USING MonPosTable, OBJ_ID, TO_GMT(BEGINDATE), TO_GMT(ENDDATE);

  I := 1;
  LOOP
    FETCH t_tablerow INTO LAT, LON;
    EXIT WHEN t_tablerow%NOTFOUND;

    p_x(I) := LAT;
    p_y(I) := LON;
    I := I + 1;
  END LOOP;

  IF(t_tablerow%ISOPEN) THEN
    CLOSE t_tablerow;
  END IF;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetFirstFullDSTPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER IS

    MaskArray TAddEquipmentTable;

    RESULT NUMBER;
    EVGMT DATE;
BEGIN
  X := 0;
  Y := 0;

  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RETURN GetFirstWorkingPoint(OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
                                 X, Y, EVGMT);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetFirstFullDSTPointC
  (MonPosCursor IN TMonPosCursor,
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  X := 0;
  Y := 0;

  IF((OBJ_ID < 0) OR (NOT(MonPosCursor%ISOPEN))) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTableC(MonPosCursor);
  RETURN GetFirstFullDSTPointT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, X, Y);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetFirstFullDSTPointT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER IS

    MaskArray TAddEquipmentTable;

    RESULT NUMBER;
    EVGMT DATE;
BEGIN
  X := 0;
  Y := 0;

  IF((OBJ_ID < 0) OR (MonPosTable IS NULL)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF(RESULT < 0) THEN
    RETURN RESULT;
  END IF;

  RETURN GetFirstWorkingPointT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
                                 X, Y, EVGMT);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetWorkingPointMoto
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   AddEquipmentNameArray OUT TStringArray,
   MotoTypeArray OUT TNumberArray,
   MotoArray OUT TNumberArray,
   MotoCountArray OUT TNumberArray,
   FuelArray OUT TNumberArray,
   AddressArray OUT TStringArray,
   TotalMoto OUT NUMBER,
   TotalFuel OUT NUMBER)
  RETURN NUMBER IS

    MonPosTable SYNCH_WL."TMonPosTable";
BEGIN
  TotalMoto := 0.0;
  TotalFuel := 0.0;

  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, BEGINDATE, ENDDATE);
  RETURN GetWorkingPointMotoT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
           AddEquipmentNameArray, MotoTypeArray, MotoArray, MotoCountArray,
           FuelArray, AddressArray, TotalMoto, TotalFuel);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetWorkingPointMotoT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   AddEquipmentNameArray OUT TStringArray,
   MotoTypeArray OUT TNumberArray,
   MotoArray OUT TNumberArray,
   MotoCountArray OUT TNumberArray,
   FuelArray OUT TNumberArray,
   AddressArray OUT TStringArray,
   TotalMoto OUT NUMBER,
   TotalFuel OUT NUMBER)
  RETURN NUMBER IS

    MaskCount NUMBER;
    j INTEGER;
    k INTEGER;

    subMaskArray TAddEquipmentTable;

    MOTO NUMBER;
    MOTO_COUNT NUMBER;
    FUEL_CONSUMPTION NUMBER;
    COUNT_FUEL_CONSUMPTION NUMBER;
    RESULT NUMBER;
    result2 NUMBER;
    result3 NUMBER;
    X_ARRAY TNumberArray;
    Y_ARRAY TNumberArray;
    ADDRESS_ARRAY TStringArray;
    cResult CHAR(5);
BEGIN
  TotalMoto := 0.0;
  TotalFuel := 0.0;

  IF((OBJ_ID < 0) OR (MonPosTable IS NULL)) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  MaskCount := MaskArray.COUNT;
  IF(MaskCount = 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  RESULT := CalcDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
                                  TotalMoto, TotalFuel);

  IF(RESULT < 0) THEN
    RETURN RESULT;
  END IF;

  j := 0;
  k := 1;
  LOOP
    j := j + 1;

    subMaskArray(1) := MaskArray(j);

    RESULT := CalcDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, subMaskArray,
                                    MOTO, FUEL_CONSUMPTION, 0, 1); -- CounMode disabled

    result2 := CalcDSTMotoByObjIdT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, subMaskArray,
                                    MOTO_COUNT, COUNT_FUEL_CONSUMPTION, 0, 2); -- CounMode enabled

    result3 := GetAllAddressesT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, subMaskArray,
                                    X_ARRAY, Y_ARRAY, ADDRESS_ARRAY);

    AddEquipmentNameArray(k) := subMaskArray(1).NAME;
    MotoTypeArray(k) := subMaskArray(1).COUNTMODE;

    IF(RESULT >= 0) THEN
      MotoArray(k) := MOTO;
      FuelArray(k) := FUEL_CONSUMPTION;
    ELSE
      MotoArray(k) := RESULT;
      FuelArray(k) := RESULT;
    END IF;

    IF(result2 >= 0) THEN
      MotoCountArray(k) := MOTO_COUNT;
      IF (RESULT >= 0) THEN
        FuelArray(k) := FuelArray(k) + COUNT_FUEL_CONSUMPTION;
      END IF;
    ELSE
      MotoCountArray(k) := RESULT;
    END IF;

    IF(result3 >= 0) THEN
      AddressArray(k) := StringArrayToString(ADDRESS_ARRAY, '/');
    ELSE
      cResult := TO_CHAR(result3, '00.0');
      AddressArray(k) := cResult;
    END IF;

    k := k + 1;

    EXIT WHEN j = MaskCount;
  END LOOP;

  RETURN CRESULT_SUCCESS; --SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetAllWorkingPoint
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   BeginAt OUT TDateArray,
   EndAt OUT TDateArray,
   X OUT TPointArray,
   Y OUT TPointArray,
   FullMoto OUT TNumberArray,
   FullFuel OUT TNumberArray,
   AddEquipmentNames OUT TStringArray,
   MotoDetails OUT TStringArray,
   FuelDetails OUT TStringArray)
  RETURN NUMBER IS

    RESULT NUMBER;
    Radius NUMBER;

    MaskArray TAddEquipmentTable;

    CentreX NUMBER;
    CentreY NUMBER;
    CentreEVGMT DATE;
    EVGMT DATE;
    cBeginAt DATE;
    cEndAt DATE;

    cX NUMBER;
    cY NUMBER;

    j INTEGER;

    AddEquipmentNameArray TStringArray;
    MotoArray TNumberArray;
    MotoCountArray TNumberArray;
    MotoTypeArray TNumberArray;
    FuelArray TNumberArray;
    AddressArray TStringArray;
    TotalMoto NUMBER;
    TotalFuel NUMBER;
BEGIN

  IF (OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  Radius := WORKING_RADIUS;
  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF (RESULT < 0) THEN
    RETURN RESULT;
  END IF;

  RESULT := GetFirstWorkingPoint(OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
                                 cX, cY, EVGMT);

  IF (RESULT < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  j := 1;
  LOOP

    RESULT := GetWorkingPointDate(OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                                  CentreX, CentreY, Radius, cBeginAt, cEndAt);

    IF (RESULT >= 0) THEN

      RESULT := GetWorkingPointMoto(OBJ_ID, cBeginAt, cEndAt, MaskArray,
                  AddEquipmentNameArray, MotoTypeArray, MotoArray, MotoCountArray,
                  FuelArray, AddressArray, TotalMoto, TotalFuel);

      FullMoto(j) := TotalMoto;
      FullFuel(j) := TotalFuel;
      AddEquipmentNames(j) := StringArrayToString(AddEquipmentNameArray);
      MotoDetails(j) := NumberArrayToString(MotoArray);
      FuelDetails(j) := NumberArrayToString(FuelArray);

    END IF;

    X(j) := cX;
    Y(j) := cY;
    BeginAt(j) := cBeginAt;
    EndAt(j) := cEndAt;

    CentreX := cX;
    CentreY := cY;
    CentreEVGMT := EVGMT;

    RESULT := GetNextWorkingPoint(OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                                  CentreX, CentreY, Radius, cX, cY, EVGMT);

    j := j + 1;
    EXIT WHEN RESULT < 0;
  END LOOP;

  RETURN CRESULT_SUCCESS; -- SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetAllWorkingPointC
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
  RETURN TCursor IS

    t_tablerow TCursor;
    WorkingTable SYNCH_WL."TWorkingPointTable" := SYNCH_WL."TWorkingPointTable"();

    RESULT NUMBER;
    Radius NUMBER;

    MaskArray TAddEquipmentTable;

    CentreX NUMBER;
    CentreY NUMBER;
    CentreEVGMT DATE;
    EVGMT DATE;
    cBeginAt DATE;
    cEndAt DATE;

    cX NUMBER;
    cY NUMBER;

    AddEquipmentNameArray TStringArray;
    MotoArray TNumberArray;
    MotoCountArray TNumberArray;
    MotoTypeArray TNumberArray;
    FuelArray TNumberArray;
    AddressArray TStringArray;

    TotalMoto NUMBER(6,4);
    TotalFuel NUMBER(6,4);
    AddEquipmentNamesItem VARCHAR2(300);
    MotoDetailsItem VARCHAR2(300);
    FuelDetailsItem VARCHAR2(300);
BEGIN

  IF (OBJ_ID < 0) THEN
    RETURN NULL;
  END IF;

  Radius := WORKING_RADIUS;
  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF (RESULT < 0) THEN
    RETURN NULL;
  END IF;

  RESULT := GetFirstWorkingPoint(OBJ_ID, BEGINDATE, ENDDATE, MaskArray,
                                    cX, cY, EVGMT);

  IF (RESULT < 0) THEN
    RETURN NULL;
  END IF;

  LOOP

    CentreX := cX;
    CentreY := cY;
    CentreEVGMT := EVGMT;

    RESULT := GetWorkingPointDate(OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                                     CentreX, CentreY, Radius, cBeginAt, cEndAt);

    IF (RESULT >= 0) THEN

      RESULT := GetWorkingPointMoto(OBJ_ID, cBeginAt, cEndAt, MaskArray,
                  AddEquipmentNameArray, MotoTypeArray, MotoArray, MotoCountArray,
                  FuelArray, AddressArray, TotalMoto, TotalFuel);

      IF (RESULT >= 0) THEN

        MotoDetailsItem := NumberArrayToString(MotoArray);
        FuelDetailsItem := NumberArrayToString(FuelArray);
        AddEquipmentNamesItem := StringArrayToString(AddEquipmentNameArray);

        WorkingTable.EXTEND;
        WorkingTable(WorkingTable.COUNT) := SYNCH_WL."TWorkingPoint"(
          cBeginAt, cEndAt, cX, cY, TotalMoto, TotalFuel,
          AddEquipmentNamesItem, MotoDetailsItem, FuelDetailsItem);

      END IF;

    END IF;

    RESULT := GetNextWorkingPoint(OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                CentreX, CentreY, Radius, cX, cY, EVGMT);

    EXIT WHEN RESULT < 0;
  END LOOP;

  OPEN t_tablerow FOR
    SELECT * FROM TABLE(CAST(WorkingTable AS SYNCH_WL."TWorkingPointTable"));

  RETURN t_tablerow; -- SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
END;

FUNCTION GetAllAddressesT
  (MonPosTable IN SYNCH_WL."TMonPosTable",
   OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   MaskArray IN TAddEquipmentTable,
   X_ARRAY OUT TNumberArray,
   Y_ARRAY OUT TNumberArray,
   ADDRESS_ARRAY OUT TStringArray)
  RETURN NUMBER IS

    X NUMBER;
    Y NUMBER;

    RESULT NUMBER;
    Radius NUMBER;

    CentreX NUMBER;
    CentreY NUMBER;
    CentreEVGMT DATE;
    EVGMT DATE;
    BeginAt DATE;
    EndAt DATE;

    AddEquipmentNameArray TStringArray;
    MotoArray TNumberArray;
    MotoCountArray TNumberArray;
    MotoTypeArray TNumberArray;
    FuelArray TNumberArray;
    TotalMoto NUMBER;
    TotalFuel NUMBER;
    k INTEGER;
BEGIN
  IF (OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  Radius := WORKING_RADIUS;

  RESULT := GetFirstWorkingPointT(MonPosTable, OBJ_ID, BEGINDATE, ENDDATE, MaskArray, X, Y, EVGMT);

  IF (RESULT < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  k := 1;
  X_ARRAY(k) := X;
  Y_ARRAY(k) := Y;
  ADDRESS_ARRAY(k) := GetAddress(X, Y);
  LOOP

    CentreX := X;
    CentreY := Y;
    CentreEVGMT := EVGMT;

    RESULT := GetWorkingPointDateT(MonPosTable, OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                CentreX, CentreY, Radius, BeginAt, EndAt);

    IF (RESULT < 0) THEN
      RETURN RESULT;
    END IF;

    RESULT := GetNextWorkingPointT(MonPosTable, OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                                  CentreX, CentreY, Radius, X, Y, EVGMT);

    IF (RESULT > 0) THEN
      X_ARRAY(k) := X;
      Y_ARRAY(k) := Y;
      ADDRESS_ARRAY(k) := GetAddress(X, Y);
    END IF;

    k := k + 1;

    EXIT WHEN RESULT < 0;
  END LOOP;

  RETURN CRESULT_SUCCESS; -- SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION TestFastBall
  (OBJ_ID IN NUMBER,
   BEGINDATE IN DATE,
   ENDDATE IN DATE,
   X OUT NUMBER,
   Y OUT NUMBER)
  RETURN NUMBER IS

    RESULT NUMBER;
    Radius NUMBER;

    MaskArray TAddEquipmentTable;

    CentreX NUMBER;
    CentreY NUMBER;
    CentreEVGMT DATE;
    EVGMT DATE;
    BeginAt DATE;
    EndAt DATE;

    AddEquipmentNameArray TStringArray;
    MotoArray TNumberArray;
    MotoCountArray TNumberArray;
    MotoTypeArray TNumberArray;
    FuelArray TNumberArray;
    AddressArray TStringArray;
    TotalMoto NUMBER;
    TotalFuel NUMBER;
BEGIN
  X := 0;
  Y := 0;

  IF (OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  Radius := WORKING_RADIUS;
  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF (RESULT < 0) THEN
    RETURN RESULT;
  END IF;

  RESULT := GetFirstWorkingPoint(OBJ_ID, BEGINDATE, ENDDATE, MaskArray, X, Y, EVGMT);

  IF (RESULT < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  LOOP

    RESULT := GetWorkingPointDate(OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                CentreX, CentreY, Radius, BeginAt, EndAt);

    IF (RESULT >= 0) THEN

      RESULT := GetWorkingPointMoto(OBJ_ID, BeginAt, EndAt, MaskArray,
                  AddEquipmentNameArray, MotoTypeArray, MotoArray, MotoCountArray,
                  FuelArray, AddressArray, TotalMoto, TotalFuel);

    END IF;

    CentreX := X;
    CentreY := Y;
    CentreEVGMT := EVGMT;

    RESULT := GetNextWorkingPoint(OBJ_ID, CentreEVGMT, ENDDATE, MaskArray,
                                  CentreX, CentreY, Radius, X, Y, EVGMT);

    EXIT WHEN RESULT < 0;
  END LOOP;

  X := CentreX;
  Y := CentreY;

  RETURN CRESULT_SUCCESS; -- SUCCESS

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

-- Connections with DB LInk

FUNCTION EverestDBLinks
  RETURN TDBLinkNameArray IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;
    DBLINKS TDBLinkNameArray;
    DBLINKNAME NVARCHAR2(50);
    j NUMBER;
BEGIN
  OPEN t_tablerow
    FOR 'SELECT DBLINKNAME FROM SYNCH_WL.EVEREST_DBLINKS WHERE DBLINKNAME IN (SELECT DB_LINK FROM all_db_links)';

  j := 1;
  LOOP
    FETCH t_tablerow INTO DBLINKNAME;
    EXIT WHEN t_tablerow%NOTFOUND;
    IF (DBLINKNAME IS NOT NULL) THEN
      DBLINKS(j) := DBLINKNAME;
      j := j + 1;
    END IF;
  END LOOP;

  RETURN DBLINKS;
END;

FUNCTION GetDBLinkNameToEverest
  (AVTO_NO IN NVARCHAR2,
   OBJ_ID IN NUMBER)
  RETURN NVARCHAR2 IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    DBLINKNAME NVARCHAR2(50);
    DBLINKS TDBLinkNameArray;
    j INTEGER;
    DBLINKS_COUNT INTEGER;
    IsSuccess NUMBER;
    sqlString VARCHAR2(200);
    RecordCount NUMBER;
    ExCount NUMBER;
BEGIN
  IF((AVTO_NO IS NULL) OR (OBJ_ID < 0)) THEN
    RETURN NULL;
  END IF;

  OPEN t_tablerow FOR 'SELECT DBLINKNAME FROM SYNCH_WL.DATASOURCE WHERE ((OBJID = :OBJID) AND (DBLINKNAME IN (SELECT DB_LINK FROM all_db_links)))'
    USING OBJ_ID;

  FETCH t_tablerow INTO DBLINKNAME;
  IF(DBLINKNAME IS NOT NULL) THEN
    RETURN DBLINKNAME;
  END IF;

  DBLINKS := EverestDBLinks;
  DBLINKS_COUNT := DBLINKS.COUNT;
  IF(DBLINKS_COUNT = 0) THEN
    RETURN NULL;
  END IF;

  j := 0;
  LOOP
    j := j + 1;
    IsSuccess := 0;
    DBLINKNAME := DBLINKS(j);
    IF(DBLINKNAME IS NOT NULL) THEN
      BEGIN
        sqlString := 'SELECT COUNT(*) FROM SYNCH_WL.V_CARDTRANSP@' || DBLINKNAME;
        sqlString := sqlString || ' WHERE (LOWER(TRIM(REPLACE(REPLACE(CARNUMBER, '' '', ''''), ''-'', ''''))) = :AVTO_NO)';
        OPEN t_tablerow FOR sqlString
          USING ConvertAvtoNo(AVTO_NO);
        FETCH t_tablerow INTO RecordCount;
        IF((RecordCount IS NOT NULL) AND (RecordCount > 0)) THEN
          IsSuccess := 1;
            --Insert DBLINK
            SELECT COUNT(*) INTO ExCount FROM SYNCH_WL.DATASOURCE WHERE (SYNCH_WL.DATASOURCE.OBJID = OBJ_ID);
            IF (ExCount = 0) THEN
              INSERT INTO SYNCH_WL.DATASOURCE VALUES (OBJ_ID, DBLINKNAME);
            END IF;
            RETURN DBLINKNAME;
        END IF;
      EXCEPTION
        WHEN OTHERS THEN
          IsSuccess := 0;
      END;
    END IF;
    EXIT WHEN j = DBLINKS_COUNT;
  END LOOP;

  RETURN NULL;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
END;

FUNCTION GetMainDataFromEverestByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   MODEL OUT VARCHAR,
   VEHICLETYPE OUT CHAR,
   ADMINNAME OUT VARCHAR2,
   FUELCONSUMPTION OUT NUMBER,
   WORKGRAPHTYPENAME OUT VARCHAR2,
   DINNERTIME OUT CHAR)
   RETURN NUMBER IS

    TYPE T_Table IS REF CURSOR;
    t_tablerow T_Table;

    AVTO_NO_TR NVARCHAR2(20);
    DBLINK NVARCHAR2(50);
    OBJ_ID NUMBER;
    sqlString VARCHAR2(400);
BEGIN
  MODEL := '';
  VEHICLETYPE := '';
  ADMINNAME := '';
  FUELCONSUMPTION := 0.0;
  WORKGRAPHTYPENAME := '';
  DINNERTIME := '';

  IF(AVTO_NO IS NULL) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  DBLINK := GetDBLinkNameToEverest(AVTO_NO, OBJ_ID);
  IF(DBLINK IS NULL) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  sqlString := 'SELECT MODEL, VEHICLETYPE, ADMINNAME, FUELCONSUMPTION, WORKGRAPHTYPENAME, DINNERTIME';
  sqlString := sqlString || ' FROM SYNCH_WL.V_CARDTRANSP@' || DBLINK;
  sqlString := sqlString || ' WHERE (LOWER(TRIM(REPLACE(REPLACE(CARNUMBER, '' '', ''''), ''-'', ''''))) = :AVTO_NO)';
  OPEN t_tablerow FOR sqlString USING ConvertAvtoNo(AVTO_NO);

  IF (t_tablerow IS NOT NULL) THEN
    FETCH t_tablerow INTO MODEL, VEHICLETYPE, ADMINNAME, FUELCONSUMPTION, WORKGRAPHTYPENAME, DINNERTIME;

    RETURN CRESULT_SUCCESS; --SUCCESS
  END IF;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetFuelConsFromEverestByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   p_RegDate IN DATE)
  RETURN NUMBER IS

    OBJ_ID NUMBER;
    DBLINK NVARCHAR2(50);
    FUELCONSUMPTION NUMBER(6,1);
    sqlString VARCHAR2(400);
    R NUMBER;
    p_CarNumber VARCHAR2(22);
    p_CarNumberN NVARCHAR2(20);
BEGIN
  FUELCONSUMPTION := -1.0;

  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  DBLINK := GetDBLinkNameToEverest(AVTO_NO, OBJ_ID);
  IF(DBLINK IS NULL) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;

  p_CarNumberN := ConvertAvtoNo(AVTO_NO);
  p_CarNumber := p_CarNumberN;
  sqlString := 'BEGIN' ||
    ':R := SYNCH_WL.WL_PROC.GetFuelConsumptionNorm@' || DBLINK || '(:AVTO_NO, :p_REG_DATE);' ||
    'END;';

  EXECUTE IMMEDIATE sqlString USING OUT R, p_CarNumber, p_RegDate;

  IF (R IS NULL) THEN
    RETURN CRESULT_NOTFOUND; --SUCCESS
  END IF;

  RETURN R;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetWayListIdByAvtoNo
  (AVTO_NO IN NVARCHAR2,
   BEGINDATE IN DATE,
   ENDDATE IN DATE)
   RETURN TCursor IS

   t_tablerow TCursor;
   DBLINK NVARCHAR2(50);
   OBJ_ID NUMBER;
   sqlString VARCHAR2(400);
BEGIN
  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN NULL;
  END IF;

  DBLINK := GetDBLinkNameToEverest(AVTO_NO, OBJ_ID);
  IF(DBLINK IS NULL) THEN
    RETURN NULL;
  END IF;

  sqlString := 'SELECT WAYLISTID, REGNUMBER, REGDATE, RETURNDATE, ADMINID, DEPARTURE, ARRIVAL, CARSPECIFICNAME';
  sqlString := sqlString || ' FROM SYNCH_WL.V_WAYLIST@' || DBLINK;
  sqlString := sqlString || ' WHERE (LOWER(TRIM(REPLACE(REPLACE(CARNUMBER, '' '', ''''), ''-'', ''''))) = :AVTO_NO)';
  sqlString := sqlString || ' AND (REGDATE >= :BEGINDATE)';
  sqlString := sqlString || ' AND (RETURNDATE <= :ENDDATE)';
  OPEN t_tablerow FOR sqlString USING ConvertAvtoNo(AVTO_NO), BEGINDATE, ENDDATE;

  RETURN t_tablerow;
END;

-- FUEL CONFIG PARSING

FUNCTION ReadFuelTransformFromConfig
  (CONFIG VARCHAR2, TransformationList OUT VARCHAR2)
   RETURN NUMBER
    IS
     index1 NUMBER;
     index2 NUMBER;
BEGIN
  TransformationList := '';

  index1 := 0;
  index2 := 0;

  index1 := INSTR(CONFIG, '74616228'); --'tab('

  IF(index1 <> 0)THEN

    index2 := INSTR(CONFIG, '29', index1); --')'

    IF ((index2 <> 0) AND (index2 - index1 > 12))  THEN

      TransformationList := REPLACE(UTL_RAW.CAST_TO_VARCHAR2(SUBSTR(CONFIG, index1 + 12, index2 - index1 - 12)), ' ', '');

      RETURN CRESULT_SUCCESS; --SUCCESS

    END IF;

  END IF;

  RETURN CRESULT_NOTFOUND;

  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

FUNCTION ParseFuelTransform
  (OBJID NUMBER, TransformationList VARCHAR2)
   RETURN SYNCH_WL."TFuelTransformationTable"
    IS

     Transform SYNCH_WL."TFuelTransformationTable" := SYNCH_WL."TFuelTransformationTable"();
     TransformationList2 VARCHAR2(32000);
     index1 INTEGER;
     index2 INTEGER;
     index3 INTEGER;
     FREQSTR VARCHAR2(20);
     FUELSTR VARCHAR2(20);
     freq NUMBER;
     fuel NUMBER;
     x2 NUMBER;
     y2 NUMBER;
     x1 NUMBER;
     y1 NUMBER;
     k NUMBER;
     DecimalPoint VARCHAR2(1);
BEGIN
    TransformationList2 := TransformationList || ',';
    index1 := 0;

    SELECT SUBSTR(VALUE, 1, 1) INTO DecimalPoint
    	FROM NLS_SESSION_PARAMETERS WHERE PARAMETER = 'NLS_NUMERIC_CHARACTERS';

    IF (DecimalPoint IS NULL) THEN
    	DecimalPoint := '.';
    END IF;

    LOOP
        index2 := INSTR(TransformationList2, ',', index1 + 1);
        index3 := INSTR(TransformationList2, ',', index2 + 1);

        EXIT WHEN ((index2 = 0) OR (index3 = 0));

        FREQSTR := SUBSTR(TransformationList2, index1 + 1, index2 - index1 - 1);
        FUELSTR := SUBSTR(TransformationList2, index2 + 1, index3 - index2 - 1);

        FREQSTR := REPLACE(FREQSTR, ',', '');
        FUELSTR := REPLACE(FUELSTR, ',', '');

        --FREQSTR := REPLACE(FREQSTR, '.', ',');
        --FUELSTR := REPLACE(FUELSTR, '.', ',');
        FREQSTR := REPLACE(FREQSTR, '.', DecimalPoint);
        FUELSTR := REPLACE(FUELSTR, '.', DecimalPoint);

        freq := to_number(FREQSTR);
        fuel := to_number(FUELSTR);

        Transform.EXTEND;

        IF ((Transform.COUNT = 1) AND (freq > 0) AND (fuel > 0)) THEN
        	Transform(Transform.COUNT) := SYNCH_WL."TFuelTransformation"(OBJID, 0.0, 0.0, 0.0);
            Transform.EXTEND;
        END IF;

        Transform(Transform.COUNT) := SYNCH_WL."TFuelTransformation"(OBJID, freq, fuel, 0.0);

        IF (Transform.COUNT > 1) THEN
            x1 := Transform(Transform.COUNT - 1).FREQ;
            y1 := Transform(Transform.COUNT - 1).FUEL;
            x2 := freq;
            y2 := fuel;
            k := (y2 - y1) / (x2 - x1);
            Transform(Transform.COUNT - 1).K := k;
        END IF;

        index1 := index3;

    END LOOP;

  RETURN Transform;

  EXCEPTION
    WHEN OTHERS THEN
     RETURN NULL;

     --Transform.EXTEND;
     --Transform(Transform.COUNT) := SYNCH_WL."TFuelTransformation"(OBJID, index1, index1, index1);
     --RETURN Transform;

END;

FUNCTION CalcFuelTransform
  (FREQ NUMBER, Transform SYNCH_WL."TFuelTransformationTable")
   RETURN NUMBER
    IS

    minFreq NUMBER;
    maxFreq NUMBER;
    x1 NUMBER;
    x2 NUMBER;
    k NUMBER;
    I INTEGER;

BEGIN
    minFreq := Transform(1).FREQ;
    maxFreq := Transform(Transform.COUNT).FREQ;
    IF (FREQ <= minFreq) THEN
        RETURN Transform(1).FUEL;
    END IF;
    IF (FREQ >= maxFreq) THEN
        RETURN Transform(Transform.COUNT).FUEL;
    END IF;

    I := 1;

    LOOP
        EXIT WHEN (I >= Transform.COUNT);

        x1 := Transform(I).FREQ;
        x2 := Transform(I + 1).FREQ;
        IF ((freq > x1) AND (freq <= x2)) THEN
            k := Transform(I).K;
            RETURN (Transform(I).FUEL + k * (Freq - Transform(I).FREQ));
        END IF;

        I := I + 1;
    END LOOP;

    RETURN CRESULT_NOTFOUND;

    EXCEPTION
        WHEN OTHERS THEN
            RETURN CRESULT_EXCEPTION;
END;

FUNCTION CalcFuelTransformByAvtoNo
  (FREQ NUMBER, p_CarNumber IN NVARCHAR2)
   RETURN NUMBER
   IS

    CONFIG VARCHAR2(32000);
    OBJ_ID NUMBER;
    bHasFuelSensor NUMBER;
    FuelTransformationList VARCHAR2(32000);
    FuelTransform SYNCH_WL."TFuelTransformationTable";
BEGIN

    -- OBJ ID

    SELECT DISTINCT MONUSER.MONOBJ.OBJID, DBMS_LOB.SUBSTR(MONUSER.MONOBJ.CONFIG, 2000, 1) INTO OBJ_ID, CONFIG
    FROM MONUSER.MONOBJ
    WHERE (ConvertAvtoNo(AVTO_NO) = ConvertAvtoNo(p_CarNumber)) AND (ROWNUM = 1);

    IF (OBJ_ID IS NULL) THEN
        RETURN CRESULT_NOTFOUND;
    END IF;

    -- FUEL

    bHasFuelSensor := ReadFuelTransformFromConfig(CONFIG, FuelTransformationList);

    IF (bHasFuelSensor <> 0) THEN
        RETURN CRESULT_NOTFOUND;
    END IF;

    FuelTransform := ParseFuelTransform(OBJ_ID, FuelTransformationList);

    IF (FuelTransform IS NULL) THEN
        RETURN CRESULT_NOTFOUND;
    END IF;

    RETURN CalcFuelTransform(FREQ, FuelTransform);

    EXCEPTION
        WHEN OTHERS THEN
            RETURN CRESULT_EXCEPTION;
END;

FUNCTION FuelThinOut
  (x SYNCH_WL."TMonPosTable", delayInMinutes NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        C SYNCH_WL."TMonPos";
        I NUMBER;
        LENGTH NUMBER;
        gmt DATE;
        totalMinutes NUMBER;
        nearP BOOLEAN;
        nearN BOOLEAN;
BEGIN
    LENGTH := x.COUNT;
    I := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

            C := x(I);
            gmt := C.GMT;
            nearP := FALSE;
            nearN := FALSE;

            IF (I > 1) THEN
                totalMinutes := 1440 * (gmt - x(I - 1).GMT);
                nearP := totalMinutes <= delayInMinutes;
            END IF;

            IF (I < LENGTH) THEN
                totalMinutes := 1440 * (x(I + 1).GMT - gmt);
                nearN := totalMinutes <= delayInMinutes;
            END IF;

            IF ((nearP) OR (nearN)) THEN
                y.EXTEND;
                y(y.COUNT) := C;
            END IF;

            I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelThinOutBySpeed
  (x SYNCH_WL."TMonPosTable", speed NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        C SYNCH_WL."TMonPos";
        I NUMBER;
        LENGTH NUMBER;
        correctSpeedC BOOLEAN;
        correctSpeedP BOOLEAN;
        correctSpeedN BOOLEAN;
BEGIN
    LENGTH := x.COUNT;
    I := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

            C := x(I);
            correctSpeedC := FALSE;
            correctSpeedP := FALSE;
            correctSpeedN := FALSE;

            IF (x(I).SPEED < speed) THEN
                correctSpeedC := TRUE;
            END IF;
            IF ((I > 1) AND (x(I - 1).SPEED < speed)) THEN
                correctSpeedP := TRUE;
            END IF;
            IF ((I < LENGTH) AND (x(I + 1).SPEED < speed)) THEN
                correctSpeedN := TRUE;
            END IF;

            IF ((correctSpeedC) OR (correctSpeedP) OR (correctSpeedN)) THEN
                y.EXTEND;
                y(y.COUNT) := C;
            END IF;

            I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelThinBack
  (x SYNCH_WL."TMonPosTable", delayInMinutes NUMBER, dx NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        y2 SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        C SYNCH_WL."TMonPos";
        L SYNCH_WL."TMonPos";
        N SYNCH_WL."TMonPos";
        I NUMBER;
        LENGTH NUMBER;
        gmt DATE;
        totalMinutes NUMBER;
        totalDx NUMBER;
        correctGmt BOOLEAN;
        correctFreq BOOLEAN;
BEGIN
    LENGTH := x.COUNT;
    IF (LENGTH = 0) THEN
    	RETURN y;
    END IF;

    L := x(x.COUNT);

	y.EXTEND;
    y(y.COUNT) := L;

    I := LENGTH - 1;
    LOOP
        EXIT WHEN (I = 0);

            C := x(I);
            N := x(I + 1);
            gmt := C.GMT;

			totalMinutes := 1440 * ABS(N.GMT - C.GMT);
            totalDx := ABS(L.FUEL - C.FUEL);

            correctGmt := (totalMinutes <= delayInMinutes);
            correctFreq := (totalDx <= dx);

            IF ((correctGmt) OR (correctFreq)) THEN
            	y.EXTEND;
            	y(y.COUNT) := C;
				I := I - 1;
            ELSE
            	I := 0;
            END IF;
    END LOOP;

    I := y.COUNT;
    LOOP
        EXIT WHEN (I = 0);

        y2.EXTEND;
        y2(y2.COUNT) := y(I);

        I := I - 1;
    END LOOP;

    RETURN y2;
END;

FUNCTION FuelThinForward
  (x SYNCH_WL."TMonPosTable", delayInMinutes NUMBER, dx NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        C SYNCH_WL."TMonPos";
        F SYNCH_WL."TMonPos";
        P SYNCH_WL."TMonPos";
        I NUMBER;
        LENGTH NUMBER;
        gmt DATE;
        totalMinutes NUMBER;
        totalDx NUMBER;
        correctGmt BOOLEAN;
        correctFreq BOOLEAN;
BEGIN
    LENGTH := x.COUNT;
    IF (LENGTH = 0) THEN
    	RETURN y;
    END IF;

    F := x(1);

	y.EXTEND;
    y(y.COUNT) := F;

    I := 2;
    LOOP
        EXIT WHEN (I > LENGTH);

            C := x(I);
            P := x(I - 1);
            gmt := C.GMT;

			totalMinutes := 1440 * ABS(C.GMT - P.GMT);
            totalDx := ABS(F.FUEL - C.FUEL);

            correctGmt := (totalMinutes <= delayInMinutes);
            correctFreq := (totalDx <= dx);

            IF ((correctGmt) OR (correctFreq)) THEN
                y.EXTEND;
                y(y.COUNT) := C;
				I := I + 1;
            ELSE
            	I := LENGTH + 1;
            END IF;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelMedianFilter
  (x SYNCH_WL."TMonPosTable", windowSize NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        C SYNCH_WL."TMonPos";
        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        window SYNCH_WL."TMonPosTable";
        I NUMBER;
        J NUMBER;
        calcedWindowSize NUMBER;
        LENGTH NUMBER;
        median NUMBER;
        cm NUMBER;
        cw NUMBER;
        SPEED NUMBER;
        FUEL NUMBER;
BEGIN
    calcedWindowSize := windowSize;
    IF (MOD(windowSize, 2) = 0) THEN
        calcedWindowSize := windowSize + 1;
    END IF;

    median := CEIL(calcedWindowSize/2);
    LENGTH := x.COUNT;

    IF (LENGTH <= calcedWindowSize)  THEN
    	RETURN x;
    END IF;

    I := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

--        IF ((I < median) OR (I > LENGTH - median + 1)) THEN
----            IF (I < median) THEN
----                cm := I;
----            ELSE
----                cm := (LENGTH + 1) - I;
----            END IF;
--            cm := 1;
--            cw := 2 * (cm - 1) + 1;
--        ELSE
--            cm := median;
--            cw := calcedWindowSize;
--        END IF;
--
--        J := 1;
--        window := SYNCH_WL."TMonPosTable"();
--        LOOP
--            EXIT WHEN (J > cw);
--
--            window.EXTEND;
--            window(window.COUNT) := x(I + J - cm);
--
--            J := J + 1;
--        END LOOP;
--
--        --window = window.OrderBy(item => item.Fuel).ToList();
--        SELECT CAST(MULTISET(SELECT * FROM TABLE(window) ORDER BY FUEL, GMT) AS SYNCH_WL."TMonPosTable")
--            INTO window FROM DUAL;
--
--        C := x(I);
--        y.EXTEND;
--
--        SPEED := window(cm).SPEED;  --C.SPEED
--        FUEL := window(cm).FUEL;    --C.FUEL
--
--        y(y.COUNT) := SYNCH_WL."TMonPos"(C.OBJID, C.GMT, C.EVGMT, C.FORMAT, C.STATE, C.LAT, C.LON,
--                                            SPEED,
--                                            C.DIST, C.INPUT,
--                                            FUEL);




        IF ((I < median) OR (I > LENGTH - median + 1)) THEN
            y.EXTEND;
            y(y.COUNT) := x(I);
        ELSE
            J := 1;
            window := SYNCH_WL."TMonPosTable"();
            LOOP
                EXIT WHEN (J > calcedWindowSize);

                window.EXTEND;
                window(window.COUNT) := x(I + J - median);

                J := J + 1;
            END LOOP;

            --window = window.OrderBy(item => item.Fuel).ToList();
            SELECT CAST(MULTISET(SELECT * FROM TABLE(window) ORDER BY FUEL, GMT) AS SYNCH_WL."TMonPosTable")
               INTO window FROM DUAL;

            C := x(I);
            y.EXTEND;

            SPEED := window(median).SPEED; --C.SPEED
            FUEL := window(median).FUEL;

            y(y.COUNT) := SYNCH_WL."TMonPos"(C.OBJID, C.GMT, C.EVGMT, C.FORMAT, C.STATE, C.LAT, C.LON,
                                             SPEED,
                                             C.DIST, C.INPUT,
                                             FUEL);
        END IF;

        I := I + 1;
    END LOOP;

    I := 1;
    LOOP
        EXIT WHEN (I >= median);

        y(I).FUEL := y(median).FUEL;
        y(I).SPEED := y(median).SPEED;

        y(LENGTH - I + 1).FUEL := y(LENGTH - median + 1).FUEL;
        y(LENGTH - I + 1).SPEED := y(LENGTH - median + 1).SPEED;

        I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelAperiodicSmoothingForward
  (x SYNCH_WL."TMonPosTable", k NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        C SYNCH_WL."TMonPos";
        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        I NUMBER;
        fuel NUMBER;
        LENGTH NUMBER;
BEGIN
    LENGTH := x.COUNT;

    IF (LENGTH > 1) THEN
        y.EXTEND;
        y(1) := x(1);

        I := 2;
        LOOP
            EXIT WHEN (I > LENGTH);

            C := x(I);
            fuel := k * C.FUEL + (1 - k) * y(I - 1).FUEL;
            y.EXTEND;
            y(y.COUNT) := SYNCH_WL."TMonPos"(C.OBJID, C.GMT, C.EVGMT, C.FORMAT, C.STATE, C.LAT, C.LON, C.SPEED, C.DIST, C.INPUT,
                                            fuel);

            I := I + 1;
        END LOOP;
    END IF;

    RETURN y;
END;

FUNCTION FuelAperiodicSmoothingBackward
  (x SYNCH_WL."TMonPosTable", k NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        C SYNCH_WL."TMonPos";
        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        I NUMBER;
        fuel NUMBER;
        LENGTH NUMBER;
BEGIN
    LENGTH := x.COUNT;

    IF (LENGTH > 1) THEN
        I := 1;
        LOOP
            EXIT WHEN (I > LENGTH);
            y.EXTEND;
            I := I + 1;
        END LOOP;

        y(LENGTH) := x(LENGTH);
        I := LENGTH - 1;
        LOOP
            EXIT WHEN (I <= 0);

            C := x(I);
            fuel := k * C.FUEL + (1 - k) * y(I + 1).FUEL;
            y(I) := SYNCH_WL."TMonPos"(C.OBJID, C.GMT, C.EVGMT, C.FORMAT, C.STATE, C.LAT, C.LON, C.SPEED, C.DIST, C.INPUT,
                                            fuel);

            I := I - 1;
        END LOOP;
    END IF;

    RETURN y;
END;

FUNCTION FuelAperiodicSmoothing
  (x SYNCH_WL."TMonPosTable", k NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        y SYNCH_WL."TMonPosTable";
BEGIN
    y := FuelAperiodicSmoothingForward(x, k);
    y := FuelAperiodicSmoothingBackward(y, k);
    RETURN y;
END;

FUNCTION FuelDigitalFilter
  (x SYNCH_WL."TMonPosTable", dxPositive NUMBER, dxNegative NUMBER)
   RETURN SYNCH_WL."TMonPosTable"
    IS

        C SYNCH_WL."TMonPos";
        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        I NUMBER;
        LENGTH NUMBER;
        dx NUMBER;
        fuel NUMBER;
        canUse BOOLEAN;
BEGIN
    LENGTH := x.COUNT;
    y.EXTEND;
    y(1) := x(1);

    I := 2;
    LOOP
        EXIT WHEN (I > LENGTH);

        C := x(I);
        dx := (C.FUEL - y(I - 1).FUEL);
        canUse := ((dx > 0) AND (dx >= dxPositive)) OR ((dx < 0) AND (dx <= -dxNegative));

        IF (canUse) THEN
            fuel := C.FUEL;
        ELSE
            fuel := y(I - 1).FUEL;
        END IF;

        y.EXTEND;
        y(y.COUNT) := SYNCH_WL."TMonPos"(C.OBJID, C.GMT, C.EVGMT, C.FORMAT, C.STATE, C.LAT, C.LON, C.SPEED, C.DIST, C.INPUT,
                                        fuel);

        I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelDeleteZeroFreqFilter
  (x SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TMonPosTable"
    IS

        C SYNCH_WL."TMonPos";
        y SYNCH_WL."TMonPosTable" := SYNCH_WL."TMonPosTable"();
        I NUMBER;
        LENGTH NUMBER;
        fuel NUMBER;
        lastFuel NUMBER;
        currentFuel NUMBER;
BEGIN
    LENGTH := x.COUNT;
    lastFuel := 0;

    I := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

        C := x(I);
        currentFuel := C.FUEL;

        IF (currentFuel = 0) THEN
            fuel := lastFuel;
        ELSE
            lastFuel := currentFuel;
            fuel := currentFuel;
        END IF;

        y.EXTEND;
        y(y.COUNT) := SYNCH_WL."TMonPos"(C.OBJID, C.GMT, C.EVGMT, C.FORMAT, C.STATE, C.LAT, C.LON, C.SPEED, C.DIST, C.INPUT, fuel);

        I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelLoading
  (original IN SYNCH_WL."TMonPosTable", filtered IN SYNCH_WL."TMonPosTable", dx IN NUMBER := 0)
   RETURN SYNCH_WL."TFuelLoadingIntervalTable"
    IS

        y SYNCH_WL."TFuelLoadingIntervalTable" := SYNCH_WL."TFuelLoadingIntervalTable"();
        I NUMBER;
        CurrentGmt DATE;
        correct BOOLEAN;
        wasCorrect BOOLEAN;
        C SYNCH_WL."TFuelLoadingInterval";
        o SYNCH_WL."TMonPos";
        f SYNCH_WL."TMonPos";
        LENGTH NUMBER;
BEGIN
    LENGTH := filtered.COUNT;
    I := 2;
    wasCorrect := FALSE;
    LOOP
        EXIT WHEN (I > LENGTH);

        correct := (filtered(I).FUEL - filtered(I - 1).FUEL) > dx;

        IF (correct) THEN

            f := filtered(I);
            CurrentGmt := f.GMT;

            IF (NOT wasCorrect) THEN

                C := SYNCH_WL."TFuelLoadingInterval"(NULL, NULL, NULL, NULL, NULL, NULL);
                C.x := SYNCH_WL."TMonPosTable"();
                C.y := SYNCH_WL."TMonPosTable"();

                y.EXTEND;
                y(y.COUNT) := C;

            END IF;

            y(y.COUNT).x.EXTEND;
            y(y.COUNT).y.EXTEND;

            --o = original.Single(item => item.GMT == CurrentGmt);
            SELECT VALUE(t1) INTO o
            FROM TABLE(CAST(original AS SYNCH_WL."TMonPosTable")) t1
            WHERE ((t1.GMT = CurrentGmt) AND (ROWNUM = 1));

            y(y.COUNT).x(y(y.COUNT).x.COUNT) := o;
            y(y.COUNT).y(y(y.COUNT).y.COUNT) := f;

        END IF;

        wasCorrect := correct;
        I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelDraining
  (original IN SYNCH_WL."TMonPosTable", filtered IN SYNCH_WL."TMonPosTable", dx IN NUMBER := 10)
   RETURN SYNCH_WL."TFuelLoadingIntervalTable"
    IS

        result SYNCH_WL."TFuelLoadingIntervalTable" := SYNCH_WL."TFuelLoadingIntervalTable"();
        I NUMBER;
        K NUMBER;
        correct BOOLEAN;
        currentInterval SYNCH_WL."TFuelLoadingInterval";
        current SYNCH_WL."TMonPos";
        next SYNCH_WL."TMonPos";
        o SYNCH_WL."TMonPos";
        f SYNCH_WL."TMonPos";
        LENGTH NUMBER;
        CurrentGmt DATE;
BEGIN
    LENGTH := filtered.COUNT;
    I := 1;
    currentInterval := NULL;
    LOOP
        EXIT WHEN (I >= LENGTH);

		current := filtered(I);
        next := filtered(I + 1);
        CurrentGmt := current.GMT;

		correct := ((currentInterval IS NULL) AND (current.FUEL - next.FUEL > dx)) OR
                   ((currentInterval IS NOT NULL) AND (current.FUEL - next.FUEL > 0));

		IF (correct) THEN
        	IF (currentInterval IS NULL) THEN
            	currentInterval := SYNCH_WL."TFuelLoadingInterval"(NULL, NULL, NULL, NULL, NULL, NULL);
                currentInterval.StartAt := current.GMT;
                currentInterval.x := SYNCH_WL."TMonPosTable"();
                currentInterval.y := SYNCH_WL."TMonPosTable"();
                result.EXTEND;
                result(result.COUNT) := currentInterval;
            END IF;

            SELECT VALUE(t1) INTO o
            FROM TABLE(CAST(original AS SYNCH_WL."TMonPosTable")) t1
            WHERE ((t1.GMT = CurrentGmt) AND (ROWNUM = 1));

			K := result.COUNT;
           	result(K).x.EXTEND;
           	result(K).y.EXTEND;
            result(K).x(result(K).x.COUNT) := o;
   	        result(K).y(result(K).y.COUNT) := current;

        ELSE
        	IF (currentInterval IS NOT NULL) THEN

                result(result.COUNT).EndAt := current.GMT;
                currentInterval := NULL;

	            SELECT VALUE(t1) INTO o
    	        FROM TABLE(CAST(original AS SYNCH_WL."TMonPosTable")) t1
        	    WHERE ((t1.GMT = CurrentGmt) AND (ROWNUM = 1));

    	        K := result.COUNT;
        	    result(K).x.EXTEND;
            	result(K).y.EXTEND;
	            result(K).x(result(K).x.COUNT) := o;
    	        result(K).y(result(K).y.COUNT) := current;

            END IF;
        END IF;

        I := I + 1;
    END LOOP;

    IF (currentInterval IS NOT NULL) THEN
    	K := result.COUNT;
        current := filtered(LENGTH - 1);
        CurrentGmt := current.GMT;

    	result(K).EndAt := CurrentGmt;

        SELECT VALUE(t1) INTO o
        FROM TABLE(CAST(original AS SYNCH_WL."TMonPosTable")) t1
        WHERE ((t1.GMT = CurrentGmt) AND (ROWNUM = 1));

		result(K).x.EXTEND;
        result(K).y.EXTEND;
        result(K).x(result(K).x.COUNT) := o;
        result(K).y(result(K).y.COUNT) := current;
    END IF;

    RETURN result;
END;

FUNCTION FuelFindLoadingWay1
  (x IN SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TFuelLoadingIntervalTable"
    IS
        y SYNCH_WL."TFuelLoadingIntervalTable" := SYNCH_WL."TFuelLoadingIntervalTable"();
        loading SYNCH_WL."TFuelLoadingIntervalTable";
        filtered SYNCH_WL."TMonPosTable";
        original SYNCH_WL."TMonPosTable";
        original_full SYNCH_WL."TMonPosTable";
        converted SYNCH_WL."TMonPosTable";
        f_begin SYNCH_WL."TMonPosTable";
        f_end SYNCH_WL."TMonPosTable";
        --o SYNCH_WL."TMonPosTable";
        I NUMBER;
        J NUMBER;
        K NUMBER;
        LENGTH NUMBER;
        MinFreq NUMBER;
        MaxFreq NUMBER;
        StartAt DATE;
        EndAt DATE;
        MinStartAt DATE;
        MaxEndAt DATE;
BEGIN
	IF (FUEL_LOAD_TIME_LIMIT > 0) THEN
    	--original_full := FuelThinOut(x, 5);
    	original_full := FuelThinOut(x, FUEL_LOAD_TIME_LIMIT);
    ELSE
	    original_full := x;
    END IF;

    -- Median filter
    original_full := FuelMedianFilter(original_full, 11);

    -- Delete zero values after engine on
    original_full := FuelDeleteZeroFreqFilter(original_full);

    -- Aperiodic smoothing filter
    filtered := FuelAperiodicSmoothing(original_full, 0.10);

    loading := FuelLoading(original_full, filtered, 1);

    LENGTH := loading.COUNT;
    I := 1;
    J := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

        --converted := FuelDigitalFilter(loading(I).x, 15, 1);
        converted := FuelDigitalFilter(loading(I).x, 30, 1);
        original := loading(I).x;
        filtered := loading(I).y;

		SELECT MAX(GMT), MAX(FUEL)
        INTO StartAt, MinFreq
        FROM
        (
            SELECT
                LAST_VALUE(GMT) OVER (ORDER BY GMT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS GMT,
                LAST_VALUE(FUEL) OVER (ORDER BY GMT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS FUEL

            FROM TABLE(converted) WHERE
                FUEL = (SELECT MIN(FUEL) FROM TABLE(converted))
        );

        SELECT MIN(GMT), MIN(FUEL)
        INTO EndAt, MaxFreq
        FROM
        (
            SELECT
                FIRST_VALUE(GMT) OVER (ORDER BY GMT) AS GMT,
                FIRST_VALUE(FUEL) OVER (ORDER BY GMT) AS FUEL
            FROM TABLE(converted)
                WHERE FUEL = (SELECT MAX(FUEL) FROM TABLE(converted))
        );

        MinStartAt := original(1).GMT;
        MaxEndAt := original(original.COUNT).GMT;
        IF (StartAt - 30/1440 < MinStartAt) THEN
            MinStartAt := StartAt - 30/1440;
        END IF;
        IF (MaxEndAt < EndAt + 30/1440) THEN
            MaxEndAt := EndAt + 30/1440;
        END IF;

        SELECT SYNCH_WL."TMonPos"(t1.OBJID, t1.GMT, t1.EVGMT, t1.FORMAT, t1.STATE, t1.LAT, t1.LON, t1.SPEED, t1.DIST, t1.INPUT, t1.FUEL)
            BULK COLLECT
            INTO f_begin
        --FROM TABLE(CAST(x AS SYNCH_WL."TMonPosTable")) t1
        FROM TABLE(CAST(original_full AS SYNCH_WL."TMonPosTable")) t1
        WHERE ((t1.GMT >= MinStartAt) AND (t1.GMT < StartAt));

        SELECT SYNCH_WL."TMonPos"(t1.OBJID, t1.GMT, t1.EVGMT, t1.FORMAT, t1.STATE, t1.LAT, t1.LON, t1.SPEED, t1.DIST, t1.INPUT, t1.FUEL)
            BULK COLLECT
            INTO f_end
        --FROM TABLE(CAST(x AS SYNCH_WL."TMonPosTable")) t1
        FROM TABLE(CAST(original_full AS SYNCH_WL."TMonPosTable")) t1
        WHERE ((t1.GMT > EndAt) AND (t1.GMT <= MaxEndAt));

        -- Filter
        f_begin := FuelMedianFilter(f_begin, 5);
        f_end := FuelMedianFilter(f_end, 5);

        f_begin := FuelThinBack(f_begin, 5, 20);
        f_end := FuelThinForward(f_end, 5, 20);

        f_begin := FuelAperiodicSmoothing(f_begin, 0.10);
        f_end := FuelAperiodicSmoothing(f_end, 0.10);


        --SELECT AVG(FUEL) INTO MinFreq
        SELECT MIN(FUEL) INTO MinFreq
        FROM
            TABLE(f_begin);
            --TABLE(original)
            --WHERE GMT < StartAt;

        --SELECT AVG(FUEL) INTO MaxFreq
        SELECT MAX(FUEL) INTO MaxFreq
        FROM
            TABLE(f_end);
            --TABLE(original)
            --WHERE GMT > EndAt;

--        SELECT MIN(FUEL), MAX(FUEL) INTO MinFreq, MaxFreq
--        FROM
--            TABLE(filtered);

		IF (MaxFreq - MinFreq > 30) THEN
        --IF ((MinFreq > 0) AND (MaxFreq - MinFreq > 30)) THEN
        --IF ((MinFreq > 0) AND (MaxFreq - MinFreq > 15)) THEN
            y.EXTEND;
            y(J) := SYNCH_WL."TFuelLoadingInterval"(NULL, NULL, NULL, NULL, NULL, NULL);
            y(J).StartAt := StartAt;
            y(J).EndAt := EndAt;
            y(J).MinFreq := MinFreq;
            y(J).MaxFreq := MaxFreq;
            y(J).x := converted; --f_begin
            y(J).y := filtered; --f_end
            J := J + 1;
        END IF;

        I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelFindLoadingWay2
  (x IN SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TFuelLoadingIntervalTable"
    IS
        y SYNCH_WL."TFuelLoadingIntervalTable" := SYNCH_WL."TFuelLoadingIntervalTable"();
        loading SYNCH_WL."TFuelLoadingIntervalTable";
        filtered SYNCH_WL."TMonPosTable";
        original SYNCH_WL."TMonPosTable";
        converted SYNCH_WL."TMonPosTable";
        I NUMBER;
        J NUMBER;
        LENGTH NUMBER;
        MinFreq NUMBER;
        MaxFreq NUMBER;
        StartAt DATE;
        EndAt DATE;
BEGIN
    -- ??????? ????????
    original := FuelMedianFilter(x, 20);

    -- ??????????
    filtered := FuelAperiodicSmoothing(original, 0.10);

    --????????? ??????? - ??????? ???????? ?? ?????????, ?????? 15 ??/?
    --filtered := FuelThinOutBySpeed(filtered, 15);
    filtered := FuelThinOutBySpeed(filtered, 30);

    --????????? ??????? - ??????? ????????, ??????????? ?????? ??? ?? 5 ?????
    filtered := FuelThinOut(filtered, 5);

    loading := FuelLoading(original, filtered);

    LENGTH := loading.COUNT;
    I := 1;
    J := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

        converted := FuelDigitalFilter(loading(I).x, 15, 1);

        SELECT GMT, FUEL INTO StartAt, MinFreq
        FROM
        (
            SELECT
                LAST_VALUE(GMT) OVER (ORDER BY GMT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS GMT,
                LAST_VALUE(FUEL) OVER (ORDER BY GMT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS FUEL

            FROM TABLE(converted) WHERE
                FUEL = (SELECT MIN(FUEL) FROM TABLE(converted))
        ) WHERE ROWNUM = 1;

        SELECT GMT, FUEL INTO EndAt, MaxFreq
        FROM
        (
            SELECT
                FIRST_VALUE(GMT) OVER (ORDER BY GMT) AS GMT,
                FIRST_VALUE(FUEL) OVER (ORDER BY GMT) AS FUEL
            FROM TABLE(converted)
                WHERE FUEL = (SELECT MAX(FUEL) FROM TABLE(converted))
        ) WHERE ROWNUM = 1;

        --IF ((MinFreq > 0) AND (MaxFreq - MinFreq > 15)) THEN
        IF ((MinFreq > 0) AND (MaxFreq - MinFreq > 30)) THEN
            y.EXTEND;
            y(J) := SYNCH_WL."TFuelLoadingInterval"(NULL, NULL, NULL, NULL, NULL, NULL);
            y(J).StartAt := StartAt;
            y(J).EndAt := EndAt;
            y(J).MinFreq := MinFreq;
            y(J).MaxFreq := MaxFreq;
            y(J).x := converted;
            J := J + 1;
        END IF;

        I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION FuelFindDrainWay1
  (x IN SYNCH_WL."TMonPosTable")
   RETURN SYNCH_WL."TFuelLoadingIntervalTable"
    IS
        y SYNCH_WL."TFuelLoadingIntervalTable" := SYNCH_WL."TFuelLoadingIntervalTable"();
        loading SYNCH_WL."TFuelLoadingIntervalTable";
        filtered SYNCH_WL."TMonPosTable";
        original SYNCH_WL."TMonPosTable";
        original_full SYNCH_WL."TMonPosTable";
        f_begin SYNCH_WL."TMonPosTable";
        f_end SYNCH_WL."TMonPosTable";
        --o SYNCH_WL."TMonPosTable";
        I NUMBER;
        J NUMBER;
        K NUMBER;
        LENGTH NUMBER;
        f_begin_max NUMBER;
        f_end_max NUMBER;
        StartAt DATE;
        EndAt DATE;
        MinStartAt DATE;
        MaxEndAt DATE;
        v_start SYNCH_WL."TMonPos";
        v_end SYNCH_WL."TMonPos";
        IsEngineValid BOOLEAN;
BEGIN
	IF (FUEL_DRAIN_TIME_LIMIT > 0) THEN
        --original_full := FuelThinOut(x, 5);
    	original_full := FuelThinOut(x, FUEL_DRAIN_TIME_LIMIT);
    ELSE
	    original_full := x;
    END IF;

	-- Median Filter
    original_full := FuelMedianFilter(original_full, 11);

    -- Delete zero values after engine on
    original_full := FuelDeleteZeroFreqFilter(original_full);

    filtered := original_full;

    loading := FuelDraining(original_full, filtered, 10);

    LENGTH := loading.COUNT;
    I := 1;
    J := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

        original := loading(I).x;
        filtered := loading(I).y;

		StartAt := loading(I).StartAt;
        EndAt := loading(I).EndAt;
        v_start := loading(I).x(1);
        v_end := loading(I).x(loading(I).x.COUNT);
        MinStartAt := StartAt - 30/1440;
        MaxEndAt := EndAt + 30/1440;

        IsEngineValid := TRUE;
        IF (FUEL_DRAIN_ENGINE_CONTROL) THEN
        	-- Check that engine is switch of
        	IsEngineValid := (UTL_RAW.BIT_AND(v_start.STATE, HEXTORAW('00010000')) = HEXTORAW('00000000'));
        END IF;

        IF (IsEngineValid) THEN

          SELECT SYNCH_WL."TMonPos"(t1.OBJID, t1.GMT, t1.EVGMT, t1.FORMAT, t1.STATE, t1.LAT, t1.LON, t1.SPEED, t1.DIST, t1.INPUT, t1.FUEL)
              BULK COLLECT
              INTO f_begin
          FROM TABLE(CAST(original_full AS SYNCH_WL."TMonPosTable")) t1
          WHERE ((t1.GMT >= MinStartAt) AND (t1.GMT < StartAt));

          SELECT SYNCH_WL."TMonPos"(t1.OBJID, t1.GMT, t1.EVGMT, t1.FORMAT, t1.STATE, t1.LAT, t1.LON, t1.SPEED, t1.DIST, t1.INPUT, t1.FUEL)
              BULK COLLECT
              INTO f_end
          FROM TABLE(CAST(original_full AS SYNCH_WL."TMonPosTable")) t1
          WHERE ((t1.GMT > EndAt) AND (t1.GMT <= MaxEndAt));

          IF ((f_begin.COUNT > 0) AND (f_end.COUNT > 0)) THEN

            -- Filter
            f_begin := FuelMedianFilter(f_begin, 5);
            f_end := FuelMedianFilter(f_end, 5);

            f_begin := FuelThinBack(f_begin, 0, 5);
            f_end := FuelThinForward(f_end, 0, 5);

            f_begin := FuelAperiodicSmoothing(f_begin, 0.10);
            f_end := FuelAperiodicSmoothing(f_end, 0.10);

			SELECT MAX(FUEL) INTO f_begin_max
            FROM
            	TABLE(f_begin);

            SELECT MAX(FUEL) INTO f_end_max
            FROM
            	TABLE(f_end);

			IF (f_begin_max - f_end_max > 0) THEN
              y.EXTEND;
              y(J) := SYNCH_WL."TFuelLoadingInterval"(NULL, NULL, NULL, NULL, NULL, NULL);
              y(J).StartAt := StartAt;
              y(J).EndAt := EndAt;
              y(J).MinFreq := f_begin_max;
              y(J).MaxFreq := f_end_max;
              y(J).x := f_begin;
              y(J).y := f_end;
              J := J + 1;
            END IF;

          END IF;

        END IF;

        I := I + 1;
    END LOOP;

    RETURN y;
END;

FUNCTION MonPosTableToXml(x SYNCH_WL."TMonPosTable")
   RETURN XMLTYPE
    IS

        C SYNCH_WL."TMonPos";
        I NUMBER;
        fuel NUMBER;
        LENGTH NUMBER;
        doc XMLTYPE;
        node XMLTYPE;
        xml VARCHAR2(32000);
BEGIN
    doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><response/>');

    IF (x IS NOT NULL) THEN

        LENGTH := x.COUNT;
        I := 1;
        LOOP
            EXIT WHEN (I > LENGTH);

            C := x(I);

            xml := '<?xml version="1.0" encoding="windows-1251"?>' ||
                '<pos>' ||
                '<gmt>' || TO_CHAR(C.GMT, 'YYYY-MM-DD HH24:MI:SS') || '</gmt>' ||
                '<fuel>' || TO_CHAR(C.FUEL, '00000.0000') || '</fuel>' ||
                '<speed>' || TO_CHAR(C.SPEED, '00000.0000') || '</speed>' ||
                '<state>' || RAWTOHEX(C.STATE) || '</state>' ||
                '</pos>';

            node := XMLTYPE(xml);
            doc := XMLTYPE.APPENDCHILDXML(doc, '/response', node);

            I := I + 1;
        END LOOP;

    END IF;

    RETURN doc;
END;

FUNCTION MonPosTableToXmlClob(x SYNCH_WL."TMonPosTable")
   RETURN CLOB
    IS

        doc XMLTYPE;
BEGIN
    doc := MonPosTableToXml(x);
    RETURN doc.getClobVal();
END;

FUNCTION FuelLoadingTableToXml(x SYNCH_WL."TFuelLoadingIntervalTable")
   RETURN XMLTYPE
    IS

        C SYNCH_WL."TFuelLoadingInterval";
        I NUMBER;
        fuel NUMBER;
        LENGTH NUMBER;
        doc XMLTYPE;
        node XMLTYPE;
        xml VARCHAR2(32000);

        xLength NUMBER;
BEGIN
    doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><loading/>');

    IF (x IS NOT NULL) THEN

        LENGTH := x.COUNT;
        I := 1;
        LOOP
            EXIT WHEN (I > LENGTH);

            C := x(I);

            xLength := -1;
            IF (C.x IS NOT NULL) THEN
                xLength := C.x.COUNT;
            END IF;

            xml := '<?xml version="1.0" encoding="windows-1251"?>' ||
                '<fuel>' ||
                '<equipment>1</equipment>' ||
                '<start>' || TO_CHAR(C.StartAt, 'YYYY-MM-DD HH24:MI:SS') || '</start>' ||
                '<end>' || TO_CHAR(C.EndAt, 'YYYY-MM-DD HH24:MI:SS') || '</end>' ||
                '<min>' || TO_CHAR(C.MinFreq, '00000.0000') || '</min>' ||
                '<max>' || TO_CHAR(C.MaxFreq, '00000.0000') || '</max>' ||
                '<length>' || TO_CHAR(xLength) || '</length>' ||
                '<x/>' ||
                '<y/>' ||
                '</fuel>';

            node := XMLTYPE(xml);
            node := XMLTYPE.APPENDCHILDXML(node, '/fuel/x', MonPosTableToXml(C.x));
            node := XMLTYPE.APPENDCHILDXML(node, '/fuel/y', MonPosTableToXml(C.y));

            doc := XMLTYPE.APPENDCHILDXML(doc, '/loading', node);

            I := I + 1;
        END LOOP;

    END IF;

    RETURN doc;
END;

FUNCTION FuelLoadingTableToXmlClob(x SYNCH_WL."TFuelLoadingIntervalTable")
   RETURN CLOB
    IS

        doc XMLTYPE;
BEGIN
    doc := FuelLoadingTableToXml(x);
    RETURN doc.getClobVal();
END;

FUNCTION GetTransformationToXml(p_CarNumber IN NVARCHAR2)
   RETURN XMLTYPE

    IS
	    CONFIG VARCHAR2(32000);
    	OBJ_ID NUMBER;
	    FuelTransformationList VARCHAR2(32000);
    	FuelTransform SYNCH_WL."TFuelTransformationTable";
      bHasFuelSensor NUMBER;
      C SYNCH_WL."TFuelTransformation";
      I NUMBER;
      LENGTH NUMBER;
      doc XMLTYPE;
      node XMLTYPE;
      xml VARCHAR2(32000);
BEGIN
    doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><transformation/>');

    SELECT DISTINCT MONUSER.MONOBJ.OBJID, DBMS_LOB.SUBSTR(MONUSER.MONOBJ.CONFIG, 2000, 1) INTO OBJ_ID, CONFIG
    FROM MONUSER.MONOBJ
    WHERE (ConvertAvtoNo(AVTO_NO) = ConvertAvtoNo(p_CarNumber)) AND (ROWNUM = 1);

    IF (OBJ_ID IS NULL) THEN
        RETURN doc;
    END IF;

    bHasFuelSensor := ReadFuelTransformFromConfig(CONFIG, FuelTransformationList);

    IF (bHasFuelSensor <> 0) THEN
        RETURN doc;
    END IF;

    FuelTransform := ParseFuelTransform(OBJ_ID, FuelTransformationList);

    IF (FuelTransform IS NULL) THEN

    	xml := '<?xml version="1.0" encoding="windows-1251"?>' ||
               '<error>' ||
        	     '<transformationList>' || FuelTransformationList || '</transformationList>' ||
               '</error>';
        node := XMLTYPE(xml);
        doc := XMLTYPE.APPENDCHILDXML(doc, '/transformation', node);

        RETURN doc;
    END IF;

	LENGTH := FuelTransform.COUNT;
    I := 1;
    LOOP
    	EXIT WHEN (I > LENGTH);

		C := FuelTransform(I);

        xml := '<?xml version="1.0" encoding="windows-1251"?>' ||
               '<tranform>' ||
               '<freq>' || TO_CHAR(C.FREQ, '00000.0000') || '</freq>' ||
               '<fuel>' || TO_CHAR(C.FUEL, '00000.0000') || '</fuel>' ||
               '<k>' || TO_CHAR(c.K, '00000.0000') || '</k>' ||
               '</tranform>';

        node := XMLTYPE(xml);
        doc := XMLTYPE.APPENDCHILDXML(doc, '/transformation', node);

        I := I + 1;
    END LOOP;

    RETURN doc;
END;

FUNCTION GetTransformationToXmlClob(p_CarNumber IN NVARCHAR2)
   RETURN CLOB
    IS

        doc XMLTYPE;
BEGIN
    doc := GetTransformationToXml(p_CarNumber);
    RETURN doc.getClobVal();
END;

   
FUNCTION GetGpsFaultByObjId(OBJ_ID IN NUMBER, BEGINDATE IN DATE, ENDDATE IN DATE)
  RETURN NUMBER
   IS

        GpsFaulesCount NUMBER;
BEGIN

  SELECT
    COUNT(*)
    INTO GpsFaulesCount
    FROM MONUSER.MONPOS
    WHERE
    (
      (OBJID = OBJ_ID) AND 
      (GMT >= TO_GMT(BEGINDATE)) AND (GMT <= TO_GMT(ENDDATE)) AND
      (UTL_RAW.BIT_AND(FORMAT, CFORMAT_LAT_LON) <> CFORMAT_LAT_LON)
    );
  
  IF (GpsFaulesCount > 0) THEN
    RETURN 1;
  END IF;
  
  RETURN 0;
  
  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

FUNCTION GetGpsFault(AVTO_NO IN NVARCHAR2, BEGINDATE IN DATE, ENDDATE IN DATE)
  RETURN NUMBER
   IS
   
     OBJ_ID NUMBER;   
BEGIN
  OBJ_ID := GetObjIdByAvtoNo(AVTO_NO);
  IF(OBJ_ID < 0) THEN
    RETURN CRESULT_NOTFOUND;
  END IF;
  
  RETURN GetGpsFaultByObjId(OBJ_ID, BEGINDATE, ENDDATE);    

  EXCEPTION
    WHEN OTHERS THEN
     RETURN CRESULT_EXCEPTION;
END;

-- GET STK DATA

PROCEDURE get_stk_data
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE)
   IS

     MonPosTable SYNCH_WL."TMonPosTable";
     OBJ_ID NUMBER;
     FuelConsumption NUMBER := 0.0;
     RESULT NUMBER;
     IsDst NUMBER;
BEGIN
  p_IMP_RUN := -1.0;
  p_IMP_FUELDEPLETION := -1.0;
  p_IMP_WORKEADD := -1.0;
  p_IMP_FUELDEPLETIONADD := -1.0;
  p_COORD_X := -1.0;
  p_COORD_Y := -1.0;
  p_IMP_ADDRESS := '';
  p_IMP_STARDATE := p_RegDate;
  p_IMP_ENDDATE := p_ReturnDate;

  OBJ_ID := GetObjIdByAvtoNo(p_CarNumber);

  --LOG_STK(p_RegDate, p_ReturnDate, p_CarNumber || '_NULL', OBJ_ID, 0.0, 0.0);

  IF(OBJ_ID < 0) THEN
    RETURN;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, p_RegDate, p_ReturnDate);

  p_IMP_RUN := CalcDistByObjIdT(MonPosTable, OBJ_ID, p_RegDate, p_ReturnDate);

  --LOG_STK(p_RegDate, p_ReturnDate, p_CarNumber || '_DIST', OBJ_ID, 0.0, p_IMP_RUN);

  RESULT := CalcFullDSTMotoByObjIdT(MonPosTable, OBJ_ID, p_RegDate, p_ReturnDate, p_IMP_WORKEADD, p_IMP_FUELDEPLETIONADD);

  IsDst := IsDSTAvtoByAvtoNo(p_CarNumber);
  FuelConsumption := GetFuelConsFromEverestByAvtoNo(p_CarNumber, p_RegDate);

  IF ((p_IMP_RUN >= 0.0) AND (FuelConsumption >= 0.0) AND (IsDst <= 0)) THEN
    p_IMP_FUELDEPLETION := (p_IMP_RUN / 100.0) * FuelConsumption; -- For avto
  END IF;

  IF ((RESULT >= 0) AND (FuelConsumption >= 0.0) AND (IsDst > 0)) THEN
      p_IMP_FUELDEPLETION := (p_IMP_WORKEADD) * FuelConsumption; -- For DST
  END IF;

  IF (RESULT < 0) THEN
    p_IMP_WORKEADD := -1;
    p_IMP_FUELDEPLETIONADD := -1;
  END IF;

  --LOG_STK(p_RegDate, p_ReturnDate, p_CarNumber, OBJ_ID, p_IMP_WORKEADD, p_IMP_RUN);

  RESULT := GetFirstFullDSTPointT(MonPosTable, OBJ_ID, p_RegDate, p_ReturnDate, p_COORD_X, p_COORD_Y);

  IF (RESULT >= 0) THEN
    p_IMP_ADDRESS := GetAddress(p_COORD_X, p_COORD_Y);
  ELSE
    p_COORD_X := RESULT;
    p_COORD_Y := RESULT;
  END IF;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

PROCEDURE get_stk_data_gps
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   p_IMP_GPSFAULT OUT NUMBER)
   IS
   
     RES NUMBER;
BEGIN
  
  get_stk_data(p_CarNumber, p_RegDate, p_ReturnDate, p_IMP_RUN, p_IMP_FUELDEPLETION,
               p_IMP_WORKEADD, p_IMP_FUELDEPLETIONADD, p_COORD_X, p_COORD_Y,
               p_IMP_ADDRESS, p_IMP_STARDATE, p_IMP_ENDDATE);

  p_IMP_GPSFAULT := GetGpsFault(p_CarNumber, p_IMP_STARDATE, p_IMP_ENDDATE);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

PROCEDURE get_stk_data_detail
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   DETAIL OUT VARCHAR2)
   IS

     MonPosTable SYNCH_WL."TMonPosTable";
     OBJ_ID NUMBER;
     FuelConsumption NUMBER;
     RESULT NUMBER;
     IsDst NUMBER;

     MaskArray TAddEquipmentTable;
     MotoArray TNumberArray;
     MotoCountArray TNumberArray;
     MotoTypeArray TNumberArray;
     FuelArray TNumberArray;
     AddEquipmentNameArray TStringArray;
     AddressArray TStringArray;
     MOTO NUMBER;
     FUEL_CONSUMPTION NUMBER;
     cResult CHAR(5);
BEGIN
  p_IMP_RUN := -1.0;
  p_IMP_FUELDEPLETION := -1.0;
  p_IMP_WORKEADD := -1.0;
  p_IMP_FUELDEPLETIONADD := -1.0;
  p_COORD_X := -1.0;
  p_COORD_Y := -1.0;
  p_IMP_ADDRESS := '';
  p_IMP_STARDATE := p_RegDate;
  p_IMP_ENDDATE := p_ReturnDate;
  DETAIL := '';

  OBJ_ID := GetObjIdByAvtoNo(p_CarNumber);

  --LOG_STK(p_RegDate, p_ReturnDate, p_CarNumber || '_NULL', OBJ_ID, 0.0, 0.0);
  --LOG_STK(p_RegDate, p_ReturnDate, p_CarNumber || '_NULL', OBJ_ID, 0.0, 0.0, 'CALL_BEGIN');

  IF(OBJ_ID < 0) THEN
    RETURN;
  END IF;

  MonPosTable := GetMonPosTable(OBJ_ID, p_RegDate, p_ReturnDate);

  get_stk_data(p_CarNumber, p_RegDate, p_ReturnDate, p_IMP_RUN, p_IMP_FUELDEPLETION,
               p_IMP_WORKEADD, p_IMP_FUELDEPLETIONADD, p_COORD_X, p_COORD_Y,
               p_IMP_ADDRESS, p_IMP_STARDATE, p_IMP_ENDDATE);

  -- GET DETAIL DATA

  RESULT := GetDSTMaskByObjId(OBJ_ID, MaskArray);

  IF (RESULT >= 0) THEN

    RESULT := GetWorkingPointMotoT(MonPosTable, OBJ_ID, p_RegDate, p_ReturnDate, MaskArray,
                 AddEquipmentNameArray, MotoTypeArray, MotoArray, MotoCountArray,
                 FuelArray, AddressArray, MOTO, FUEL_CONSUMPTION);

    IF (RESULT >= 0) THEN
      DETAIL := DetailDataArrayToString(AddEquipmentNameArray, MotoTypeArray, MotoArray,
                 MotoCountArray, FuelArray, AddressArray);
    ELSE
      cResult := TO_CHAR(RESULT, '00.0');
      DETAIL := cResult;
    END IF;

  END IF;

  --LOG_STK(p_RegDate, p_ReturnDate, p_CarNumber, OBJ_ID, p_IMP_WORKEADD, p_IMP_RUN, DETAIL);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

PROCEDURE get_stk_data_detail_gps
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   DETAIL OUT VARCHAR2,
   p_IMP_GPSFAULT OUT NUMBER)
   IS

BEGIN
  
  get_stk_data_detail(p_CarNumber, p_RegDate, p_ReturnDate, p_IMP_RUN, p_IMP_FUELDEPLETION,
               p_IMP_WORKEADD, p_IMP_FUELDEPLETIONADD, p_COORD_X, p_COORD_Y,
               p_IMP_ADDRESS, p_IMP_STARDATE, p_IMP_ENDDATE, DETAIL);
               
  p_IMP_GPSFAULT := GetGpsFault(p_CarNumber, p_IMP_STARDATE, p_IMP_ENDDATE);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

PROCEDURE get_stk_data_fuel
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   p_FUEL_OnRegDate OUT NUMBER,
   p_FUEL_OnReturnDate OUT NUMBER)
   IS

    MonPosTable SYNCH_WL."TMonPosTable";
    CONFIG VARCHAR2(32000);
    OBJ_ID NUMBER;
    bHasFuelSensor NUMBER;
    FuelTransformationList VARCHAR2(32000);
    FuelTransform SYNCH_WL."TFuelTransformationTable";
    FREQ_OnRegDate NUMBER;
    FREQ_OnReturnDate NUMBER;
    GMT_RegDate DATE;
    GMT_ReturnDate DATE;
BEGIN
  p_IMP_RUN := -1.0;
  p_IMP_FUELDEPLETION := -1.0;
  p_IMP_WORKEADD := -1.0;
  p_IMP_FUELDEPLETIONADD := -1.0;
  p_COORD_X := -1.0;
  p_COORD_Y := -1.0;
  p_IMP_ADDRESS := '';
  p_IMP_STARDATE := p_RegDate;
  p_IMP_ENDDATE := p_ReturnDate;
  p_FUEL_OnRegDate := -1;
  p_FUEL_OnReturnDate := -1;

  -- OBJ ID

  SELECT DISTINCT MONUSER.MONOBJ.OBJID, DBMS_LOB.SUBSTR(MONUSER.MONOBJ.CONFIG, 2000, 1) INTO OBJ_ID, CONFIG
    FROM MONUSER.MONOBJ
    WHERE (ConvertAvtoNo(AVTO_NO) = ConvertAvtoNo(p_CarNumber)) AND (ROWNUM = 1);

  IF (OBJ_ID IS NULL) THEN
    RETURN;
  END IF;

  -- STK DATA

  MonPosTable := GetMonPosTable(OBJ_ID, p_RegDate, p_ReturnDate);

  get_stk_data(p_CarNumber, p_RegDate, p_ReturnDate, p_IMP_RUN, p_IMP_FUELDEPLETION,
               p_IMP_WORKEADD, p_IMP_FUELDEPLETIONADD, p_COORD_X, p_COORD_Y,
               p_IMP_ADDRESS, p_IMP_STARDATE, p_IMP_ENDDATE);

  -- FUEL

  bHasFuelSensor := ReadFuelTransformFromConfig(CONFIG, FuelTransformationList);

  IF (bHasFuelSensor = 0) THEN

    FuelTransform := ParseFuelTransform(OBJ_ID, FuelTransformationList);

    GMT_RegDate := TO_GMT(p_RegDate);
    GMT_ReturnDate := TO_GMT(p_ReturnDate);

    SELECT pFirstValue, pLastValue
    INTO FREQ_OnRegDate, FREQ_OnReturnDate
    FROM
    (
        SELECT
            FIRST_VALUE(FUEL) OVER (ORDER BY GMT) AS pFirstValue,
            LAST_VALUE(FUEL) OVER (ORDER BY GMT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS pLastValue
        FROM TABLE(CAST(MonPosTable AS SYNCH_WL."TMonPosTable"))
        WHERE
          (OBJID = OBJ_ID)
    )
    WHERE (ROWNUM = 1);

    IF (FREQ_OnRegDate IS NOT NULL) THEN
      p_FUEL_OnRegDate := CalcFuelTransform(FREQ_OnRegDate, FuelTransform);
    END IF;

    IF (FREQ_OnReturnDate IS NOT NULL) THEN
      p_FUEL_OnReturnDate := CalcFuelTransform(FREQ_OnReturnDate, FuelTransform);
    END IF;

  END IF;

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

PROCEDURE get_stk_data_fuel_gps
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_IMP_RUN OUT NUMBER,
   p_IMP_FUELDEPLETION OUT NUMBER,
   p_IMP_WORKEADD OUT NUMBER,
   p_IMP_FUELDEPLETIONADD OUT NUMBER,
   p_COORD_X OUT NUMBER,
   p_COORD_Y OUT NUMBER,
   p_IMP_ADDRESS OUT VARCHAR2,
   p_IMP_STARDATE OUT DATE,
   p_IMP_ENDDATE OUT DATE,
   p_FUEL_OnRegDate OUT NUMBER,
   p_FUEL_OnReturnDate OUT NUMBER,
   p_IMP_GPSFAULT OUT NUMBER)
   IS

BEGIN
  
  get_stk_data_fuel(p_CarNumber, p_RegDate, p_ReturnDate, p_IMP_RUN, p_IMP_FUELDEPLETION,
               p_IMP_WORKEADD, p_IMP_FUELDEPLETIONADD, p_COORD_X, p_COORD_Y,
               p_IMP_ADDRESS, p_IMP_STARDATE, p_IMP_ENDDATE, p_FUEL_OnRegDate, p_FUEL_OnRegDate);

  p_IMP_GPSFAULT := GetGpsFault(p_CarNumber, p_IMP_STARDATE, p_IMP_ENDDATE);

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

PROCEDURE get_fuel_sensor_vehicles
  (p_Response OUT VARCHAR2)
    IS
      doc XMLTYPE;
      node XMLTYPE;
      xml NVARCHAR2(2000);
      CONFIG VARCHAR2(32000);
      FuelTransformation VARCHAR2(32000);
      AVTO_NO NVARCHAR2(20);
      TYPE T_Table IS REF CURSOR;
      t_tablerow T_Table;
      bHasFuelSensor NUMBER;
BEGIN
  p_Response := '';

  doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><response/>');

  OPEN t_tablerow FOR
    SELECT ConvertAvtoNo(AVTO_NO) AS AVTO_NO, DBMS_LOB.SUBSTR(MONUSER.MONOBJ.CONFIG, 2000, 1)
    FROM MONUSER.MONOBJ
    WHERE OBJID IN
    (
        SELECT FIRST_VALUE(OBJID) OVER (PARTITION BY AVTO_NO)
        FROM MONUSER.MONOBJ
        WHERE
    	    (AVTO_NO IS NOT NULL) AND
            (CONFIG IS NOT NULL) AND
            (DBMS_LOB.GETLENGTH(CONFIG) > 0)
            --AND (DBMS_LOB.GETLENGTH(CONFIG) < 2000)
    );

  LOOP
    FETCH t_tablerow INTO AVTO_NO, CONFIG;
    EXIT WHEN t_tablerow%NOTFOUND;

    bHasFuelSensor := ReadFuelTransformFromConfig(CONFIG, FuelTransformation);
    IF (bHasFuelSensor = 0) THEN
      xml := '<?xml version="1.0" encoding="windows-1251"?><n>' || AVTO_NO || '</n>';
      node := XMLTYPE(xml);
      doc := XMLTYPE.APPENDCHILDXML(doc, '/response', node);
    END IF;

  END LOOP;

  p_Response := doc.getStringVal();

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

PROCEDURE get_stk_data_fuel_xml
  (p_CarNumber IN VARCHAR2,
   p_RegDate IN DATE,
   p_ReturnDate IN DATE,
   p_Response OUT VARCHAR2)
   IS

    CONFIG VARCHAR2(32000);
    OBJ_ID NUMBER;
    doc XMLTYPE;
    node XMLTYPE;
    xml NVARCHAR2(32000);
    bHasFuelSensor NUMBER;
    FuelTransformationList VARCHAR2(32000);
    FuelTransform SYNCH_WL."TFuelTransformationTable";
    MonPosTable SYNCH_WL."TMonPosTable";
    Loading SYNCH_WL."TFuelLoadingIntervalTable";
    Draining SYNCH_WL."TFuelLoadingIntervalTable";
    C SYNCH_WL."TFuelLoadingInterval";
    StartAt date;
    EndAt date;
    LENGTH NUMBER;
    I NUMBER;
    fuel NUMBER;
BEGIN
    p_Response := '';

    -- OBJ ID

    SELECT DISTINCT MONUSER.MONOBJ.OBJID, DBMS_LOB.SUBSTR(MONUSER.MONOBJ.CONFIG, 2000, 1) INTO OBJ_ID, CONFIG
    FROM MONUSER.MONOBJ
    WHERE (ConvertAvtoNo(AVTO_NO) = ConvertAvtoNo(p_CarNumber)) AND (ROWNUM = 1);

    IF (OBJ_ID IS NULL) THEN
	    doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><response><car><number>' || p_CarNumber || '</number><loading/><error>Car number not found.</error></car></response>');
        p_Response := doc.getStringVal();
        RETURN;
    END IF;

    -- FUEL

    bHasFuelSensor := ReadFuelTransformFromConfig(CONFIG, FuelTransformationList);

    IF (bHasFuelSensor <> 0) THEN
	    doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><response><car><number>' || p_CarNumber || '</number><loading/><error>No Fuel Sensor.</error></car></response>');
        p_Response := doc.getStringVal();
        RETURN;
    END IF;

    FuelTransform := ParseFuelTransform(OBJ_ID, FuelTransformationList);

    IF (FuelTransform IS NULL) THEN
	    doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><response><car><number>' || p_CarNumber || '</number><loading/><error>Can not parse fuel transformation table.</error></car></response>');
        p_Response := doc.getStringVal();
        RETURN;
    END IF;

    doc := XMLTYPE('<?xml version="1.0" encoding="windows-1251"?><response><car><number>' || p_CarNumber || '</number><loading/></car></response>');

	MonPosTable := GetMonPosTable(OBJ_ID, (p_RegDate - 1), (p_ReturnDate + 1));

	-- Loading

    Loading := FuelFindLoadingWay1(MonPosTable);

    LENGTH := Loading.COUNT;
    I := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

        C := Loading(I);

        fuel := CalcFuelTransform(C.MaxFreq, FuelTransform) - CalcFuelTransform(C.MinFreq, FuelTransform);
        StartAt := TO_EVGMT(C.StartAt);
        EndAt := TO_EVGMT(C.EndAt);

        IF ((StartAt >= p_RegDate) AND (StartAt <= p_ReturnDate) AND (fuel >= FUEL_LOAD_FUEL_LIMIT)) THEN

          xml := '<?xml version="1.0" encoding="windows-1251"?>' ||
              '<fuel>' ||
              '<equipment>1</equipment>' ||
              '<gmt>' || TO_CHAR(TO_EVGMT(C.StartAt), 'YYYY-MM-DD HH24:MI:SS') || '</gmt>' ||
              --'<gmt>' || TO_CHAR(C.StartAt, 'YYYY-MM-DD HH24:MI:SS') || '</gmt>' ||
              '<value>' || TO_CHAR(fuel, '00000.0') || '</value>' ||
              '<gpsfault>0</gpsfault>' ||
              '</fuel>';

          node := XMLTYPE(xml);

          doc := XMLTYPE.APPENDCHILDXML(doc, '/response/car/loading', node);

		END IF;

        I := I + 1;
    END LOOP;

    -- Draining

    Draining := FuelFindDrainWay1(MonPosTable);

    LENGTH := Draining.COUNT;
    I := 1;
    LOOP
        EXIT WHEN (I > LENGTH);

        C := Draining(I);

        fuel := CalcFuelTransform(C.MaxFreq, FuelTransform) - CalcFuelTransform(C.MinFreq, FuelTransform);
        StartAt := TO_EVGMT(C.StartAt);
        EndAt := TO_EVGMT(C.EndAt);

        IF ((StartAt >= p_RegDate) AND (StartAt <= p_ReturnDate) AND (fuel <= -FUEL_DRAIN_FUEL_LIMIT)) THEN

          xml := '<?xml version="1.0" encoding="windows-1251"?>' ||
              '<fuel>' ||
              '<equipment>1</equipment>' ||
              '<gmt>' || TO_CHAR(TO_EVGMT(C.StartAt), 'YYYY-MM-DD HH24:MI:SS') || '</gmt>' ||
              --'<gmt>' || TO_CHAR(C.StartAt, 'YYYY-MM-DD HH24:MI:SS') || '</gmt>' ||
              '<value>' || TO_CHAR(fuel, '00000.0') || '</value>' ||
              '</fuel>';

          node := XMLTYPE(xml);

          doc := XMLTYPE.APPENDCHILDXML(doc, '/response/car/loading', node);

		END IF;

        I := I + 1;
    END LOOP;

    -- Response

    p_Response := doc.getStringVal();

  EXCEPTION
    WHEN OTHERS THEN
      RETURN;
END;

END;
